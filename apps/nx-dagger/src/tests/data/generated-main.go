// Code generated by nx-dagger. DO NOT EDIT.
package main

import (
	"dagger/monorepo-fn/internal/dagger"

	"context"
	"sync"
)

type MonorepoFn struct {
	// Root of source file
	Source *dagger.Directory
}

func New(
	// Root of source file
	// Ignore needs to mirror .gitignore
	// +ignore=["ignore","stuff/**","!allowed"]
	source *dagger.Directory,
) *MonorepoFn {
	return &MonorepoFn{
		Source: dag.Directory().WithDirectory(
			".",
			source,
			dagger.DirectoryWithDirectoryOpts{
				Exclude: []string{
					"ignore",
					"stuff/**",
					"!allowed",
				},
			},
		),
	}
}

// List all project directories, filtered by runtime
// Empty string results in all project directories
func (m *MonorepoFn) ProjectDirs(
	ctx context.Context,
	runtime string,
) ([]string, error) {

	return dag.MonorepoFnBuilder(m.Source).ProjectDirs(ctx, runtime)
}

// Execute Nx targets over all projects in dependency order
// and return the fully built monorepo directory
func (m *MonorepoFn) Build(
	ctx context.Context,
	barArg int,
	fooArg string,
) (*dagger.Directory, error) {

	type builtProject struct {
		once      *sync.Once
		directory *dagger.Directory
	}
	mapMutex := sync.RWMutex{}
	builtProjects := map[string]builtProject{}
	waitGroup := sync.WaitGroup{}
	projectDirs, projectDirsErr := dag.MonorepoFnBuilder(m.Source).ProjectDirs(ctx, "")
	if projectDirsErr != nil {
		return nil, projectDirsErr
	}
	for _, projectDir := range projectDirs {
		builtProjects[projectDir] = builtProject{
			once: &sync.Once{},
		}
		waitGroup.Add(1)
	}

	var buildError error
	var triggerProjectBuild func(projectDir string)
	var triggerProjectBuildGroup func(projectDir string)
	triggerProjectBuild = func(projectDir string) {

		monorepoFnBuilder := dag.MonorepoFnBuilder(m.Source)

		projectConfig := monorepoFnBuilder.ProjectConfig(projectDir)
		dependencyDirNames, dependencyProjectDirErr := projectConfig.DependencyProjectDirs(ctx)
		if dependencyProjectDirErr != nil {
			buildError = dependencyProjectDirErr
			return
		}

		outputDirectories := make([]*dagger.Directory, len(dependencyDirNames))
		for i, dependencyProjectDir := range dependencyDirNames {
			// Syncronously wait for each dependency to build,
			// because top-level has already kicked off each project
			triggerProjectBuildGroup(dependencyProjectDir)
			if buildError != nil {
				return
			}
			mapMutex.RLock()
			outputDirectories[i] = builtProjects[dependencyProjectDir].directory
			mapMutex.RUnlock()
		}

		if buildError != nil {
			return
		}

		directory := monorepoFnBuilder.BuildProject(
			projectDir,
			outputDirectories,
			barArg,
			fooArg,
		)

		mapMutex.Lock()
		defer mapMutex.Unlock()
		project := builtProjects[projectDir]
		project.directory = directory
		builtProjects[projectDir] = project
	}
	triggerProjectBuildGroup = func(projectDir string) {
		mapMutex.RLock()
		projectOnce := builtProjects[projectDir].once
		mapMutex.RUnlock()
		// Only run project build once, reporting wait/error groups
		projectOnce.Do(func() {
			defer waitGroup.Done()
			triggerProjectBuild(projectDir)
		})
	}

	for _, projectDir := range projectDirs {
		// kick off building for each project
		triggerProjectBuildGroup(projectDir)
	}

	waitGroup.Wait()
	if buildError != nil {
		return nil, buildError
	}

	response := dag.Directory()
	for projectDir, project := range builtProjects {
		response = response.WithDirectory(
			projectDir,
			project.directory,
		)
	}

	return response, nil
}
