// Code generated by nx-dagger. DO NOT EDIT.
package main

import (
	"<%= it.dagger.directory %>/internal/dagger"

<% if (it.conditionals.hasCi) { %>
	"context"
<% } %>
	"errors"
	"sync"

	"golang.org/x/sync/errgroup"
)

type <%= it.changeCase.pascalCase(it.dagger.name) %> struct {
	// Root of source file
	Source *dagger.Directory
}

func New(
	// Root of source file
	// Ignore needs to mirror .gitignore
	// +ignore=<%~ JSON.stringify(it.gitIgnore) %><%~ '\n' %>
	source *dagger.Directory,
) *<%= it.changeCase.pascalCase(it.dagger.name) %> {
	return &<%= it.changeCase.pascalCase(it.dagger.name) %>{
		Source: dag.Directory().WithDirectory(
			".",
			source,
			dagger.DirectoryWithDirectoryOpts{
				Exclude: []string{
				<% for (const ignored of it.gitIgnore) { %>
					"<%= ignored %>",
				<% } %>
				},
			},
		),
	}
}

type NxProjectRuntime string

const (
<% for (const runtime of [...it.runtimes.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	_runtime_<%= it.changeCase.camelCase(runtime.name) %> NxProjectRuntime = "<%= runtime.name %>"
<% } %>
)

type NxProjectDir string

const (
<% for (const project of [...it.projects.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	_project_<%= it.changeCase.camelCase(project.name) %> NxProjectDir = "<%= project.directory %>"
<% } %>
)

type NxTarget string

const (
<% for (const target of [...it.targets.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	_target_<%= it.changeCase.camelCase(target.name) %> NxTarget = "<%= target.name %>"
<% } %>
)

type NxProject struct {
	runtime                     NxProjectRuntime
	dependencyProjectDirs       []NxProjectDir
	directDependencyProjectDirs []NxProjectDir
	targets                     []NxTarget
}

var nxConfig = map[NxProjectDir]NxProject{
<% for (const project of [...it.projects.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	_project_<%= it.changeCase.camelCase(project.name) %>: {
		runtime:                     _runtime_<%= it.changeCase.camelCase(it.runtimes.get(project.runtime).name) %>,
		dependencyProjectDirs:       []NxProjectDir{
		<% for (const dependency of project.dependencies) { %>
			_project_<%= it.changeCase.camelCase(it.projects.get(dependency).name) %>,
		<% } %>
		},
		directDependencyProjectDirs: []NxProjectDir{
		<% for (const dependency of project.directDependencies) { %>
			_project_<%= it.changeCase.camelCase(it.projects.get(dependency).name) %>,
		<% } %>
		},
		targets:                     []NxTarget{
		<% for (const target of project.targets) { %>
			_target_<%= it.changeCase.camelCase(it.targets.get(target).name) %>,
		<% } %>
		},
	},
<% } %>
}

var mapMutex = sync.RWMutex{}

// Execute Nx targets over all projects in dependency order
// and return the fully built monorepo directory
func (m *<%= it.changeCase.pascalCase(it.dagger.name) %>) Build(
<% if (it.conditionals.hasCi) { %>
	ctx context.Context,
<% } %>
<% for (const arg of [...it.constructorArguments.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	<%= arg.name %> <%= arg.type %>,
<% } %>
) (*dagger.Directory, error) {

	type builtProject struct {
		once      *sync.Once
		directory *dagger.Directory
	}
	builtProjects := map[NxProjectDir]builtProject{}
	waitGroup := sync.WaitGroup{}
	var buildError error
	for projectDir := range nxConfig {
		builtProjects[projectDir] = builtProject{
			once: &sync.Once{},
		}
		waitGroup.Add(1)
	}

	var triggerProjectBuild func(projectDir NxProjectDir) error
	var triggerProjectBuildGroup func(projectDir NxProjectDir)
	triggerProjectBuild = func(projectDir NxProjectDir) error {

		projectConfig := nxConfig[projectDir]
		dependencyDirs := make(map[NxProjectDir]*dagger.Directory, len(projectConfig.dependencyProjectDirs))

		for _, dependencyProjectDir := range projectConfig.dependencyProjectDirs {
			// Syncronously wait for each dependency to build,
			// because top-level has already kicked off each project
			triggerProjectBuildGroup(dependencyProjectDir)
			if buildError != nil {
				return buildError
			}
			mapMutex.RLock()
			dependencyDirs[dependencyProjectDir] = builtProjects[dependencyProjectDir].directory
			mapMutex.RUnlock()
		}

		directory, err := m.buildProject(
		<% if (it.conditionals.hasCi) { %>
			ctx,
		<% } %>
		<% for (const arg of [...it.constructorArguments.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
			<%= arg.name %>,
		<% } %>
			projectDir,
			dependencyDirs,
		)
		if err != nil {
			if buildError == nil {
				// Not very concerned with race condition.
				// So long as _some_ early error gets flagged
				buildError = err
			}
		} else {
			mapMutex.Lock()
			defer mapMutex.Unlock()
			project := builtProjects[projectDir]
			project.directory = directory
			builtProjects[projectDir] = project
		}
		return nil
	}
	triggerProjectBuildGroup = func(projectDir NxProjectDir) {
		mapMutex.RLock()
		projectOnce := builtProjects[projectDir].once
		mapMutex.RUnlock()
		// Only run project build once, reporting wait/error groups
		projectOnce.Do(func() {
			defer waitGroup.Done()
			triggerProjectBuild(projectDir)
		})
	}

	for projectDir := range nxConfig {
		// Asyncronously kick off building for each project
		go triggerProjectBuildGroup(projectDir)
	}

	waitGroup.Wait()
	if buildError != nil {
		return nil, buildError
	}

	response := dag.Directory()
	for projectDir, project := range builtProjects {
		response = response.WithDirectory(
			string(projectDir),
			project.directory,
		)
	}

	return response, nil
}

func (m *<%= it.changeCase.pascalCase(it.dagger.name) %>) buildProject(
<% if (it.conditionals.hasCi) { %>
	ctx context.Context,
<% } %>
<% for (const arg of [...it.constructorArguments.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	<%= arg.name %> <%= arg.type %>,
<% } %>
	projectDir NxProjectDir,
	dependencyDirectories map[NxProjectDir]*dagger.Directory,
) (*dagger.Directory, error) {

<% if (it.conditionals.hasDependencyProjectDirs) { %>
	dependencyProjectDirs := make([]string, len(nxConfig[projectDir].dependencyProjectDirs))
<% } %>
<% if (it.conditionals.hasDirectDependencyProjectDirs) { %>
	directDependencyProjectDirs := make([]string, len(nxConfig[projectDir].directDependencyProjectDirs))
<% } %>

<% if (it.conditionals.hasOutput) { %>
	output := dag.Directory()
<% } %>

<% if (it.conditionals.hasDependencyProjectDirs || it.conditionals.hasOutput) { %>
	for i, directory := range nxConfig[projectDir].dependencyProjectDirs {
	<% if (it.conditionals.hasDependencyProjectDirs) { %>
		dependencyProjectDirs[i] = string(directory)
	<% } %>
	<% if (it.conditionals.hasOutput) { %>
		output = output.WithDirectory(string(directory), dependencyDirectories[directory])
	<% } %>
	}
<% } %>
<% if (it.conditionals.hasDirectDependencyProjectDirs) { %>
	for i, directory := range nxConfig[projectDir].directDependencyProjectDirs {
		directDependencyProjectDirs[i] = string(directory)
	}
<% } %>
<% if (it.conditionals.hasProjectSource) { %>
	projectSource := m.Source.Directory(string(projectDir))
<% } %>

	var built *dagger.Directory
	switch nxConfig[projectDir].runtime {
	<% for (const runtime of [...it.runtimes.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
		case _runtime_<%= it.changeCase.camelCase(runtime.name) %>:
			built = dag.<%= it.changeCase.pascalCase(runtime.preBuild.name) %>(
				<% for (const arg of runtime.preBuild.constructorArguments) { %>
					<%= it.constructorArguments.get(arg).name %>,
				<% } %>
			).Run(
			<% for (const parameter of runtime.preBuild.parameters) { %>
				<%= it.parametersMap[parameter] %>,
			<% } %>
			)
	<% } %>
		default:
			return nil, errors.New("No matching runtime: " + string(nxConfig[projectDir].runtime))
	}

	ciErrors, cancelCtx := errgroup.WithContext(ctx)

	for _, target := range nxConfig[projectDir].targets {

		switch target {
		<% for (const target of [...it.targets.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
			case _target_<%= it.changeCase.camelCase(target.name) %>:
			<% if (target.isCi) { %>
				ciErrors.Go(func() error {
					return dag.<%= it.changeCase.pascalCase(target.methodName) %>(
						<% for (const arg of target.constructorArguments) { %>
							<%= it.constructorArguments.get(arg).name %>,
						<% } %>
					).Ci(
						cancelCtx,
					<% for (const parameter of target.parameters) { %>
						<%= it.parametersMap[parameter] %>,
					<% } %>
					)
				})
			<% } else { %>
				built = dag.<%= it.changeCase.pascalCase(target.methodName) %>(
					<% for (const arg of target.constructorArguments) { %>
						<%= it.constructorArguments.get(arg).name %>,
					<% } %>
				).Run(
					<% for (const parameter of target.parameters) { %>
						<%= it.parametersMap[parameter] %>,
					<% } %>
				)
			<% } %>
		<% } %>
			default:
				return nil, errors.New("No matching target executor: " + string(target))
		}
	}

	if err := ciErrors.Wait(); err != nil {
		return nil, err
	}

	switch nxConfig[projectDir].runtime {
	<% for (const runtime of [...it.runtimes.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
		case _runtime_<%= it.changeCase.camelCase(runtime.name) %>:
			built = dag.<%= it.changeCase.pascalCase(runtime.postBuild.name) %>(
				<% for (const arg of runtime.postBuild.constructorArguments) { %>
					<%= it.constructorArguments.get(arg).name %>,
				<% } %>
			).Run(
			<% for (const parameter of runtime.postBuild.parameters) { %>
				<%= it.parametersMap[parameter] %>,
			<% } %>
			)
	<% } %>
		default:
			return nil, errors.New("No matching runtime: " + string(nxConfig[projectDir].runtime))
	}

	return built, nil
}
