// Code generated by nx-dagger. DO NOT EDIT.
package main

import (
	"dagger/<%= it.dagger.name %>/internal/dagger"

<% if (it.conditionals.hasCi) { %>
	"context"
<% } %>
	"sync"
)

type <%= it.changeCase.pascalCase(it.dagger.name) %> struct {
	// Root of source file
	Source *dagger.Directory
}

func New(
	// Root of source file
	// Ignore needs to mirror .gitignore
	// +ignore=<%~ JSON.stringify(it.gitIgnore) %><%~ '\n' %>
	source *dagger.Directory,
) *<%= it.changeCase.pascalCase(it.dagger.name) %> {
	return &<%= it.changeCase.pascalCase(it.dagger.name) %>{
		Source: source.Filter(
			dagger.DirectoryFilterOpts{
				Exclude: []string{
				<% for (const ignored of it.gitIgnore) { %>
					"<%= ignored %>",
				<% } %>
				},
			},
		),
	}
}

// List all project directories, filtered by runtime
// Empty string results in all project directories
func (m *<%= it.changeCase.pascalCase(it.dagger.name) %>) ProjectDirs(
	ctx context.Context,
	runtime string,
) ([]string, error) {

	return dag.<%= it.changeCase.pascalCase(it.dagger.name) %>Builder(m.Source).ProjectDirs(ctx, runtime)
}

// Execute Nx targets over all projects in dependency order
// and return the fully built monorepo directory
func (m *<%= it.changeCase.pascalCase(it.dagger.name) %>) Build(
<% if (it.conditionals.hasCi) { %>
	ctx context.Context,
<% } %>
<% for (const arg of [...it.constructorArguments.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	<%= arg.name %> <%= arg.type %>,
<% } %>
) (*dagger.Directory, error) {

	type builtProject struct {
		once      *sync.Once
		directory *dagger.Directory
	}
	mapMutex := sync.RWMutex{}
	builtProjects := map[string]builtProject{}
	waitGroup := sync.WaitGroup{}
	projectDirs, projectDirsErr := dag.<%= it.changeCase.pascalCase(it.dagger.name) %>Builder(m.Source).ProjectDirs(ctx, "")
	if projectDirsErr != nil {
		return nil, projectDirsErr
	}
	for _, projectDir := range projectDirs {
		builtProjects[projectDir] = builtProject{
			once: &sync.Once{},
		}
		waitGroup.Add(1)
	}

	var buildError error
	var triggerProjectBuild func(projectDir string)
	var triggerProjectBuildGroup func(projectDir string)
	triggerProjectBuild = func(projectDir string) {

		<%= it.changeCase.camelCase(it.dagger.name) %>Builder := dag.<%= it.changeCase.pascalCase(it.dagger.name) %>Builder(m.Source)

		projectConfig := <%= it.changeCase.camelCase(it.dagger.name) %>Builder.ProjectConfig(projectDir)
		dependencyDirNames, dependencyProjectDirErr := projectConfig.DependencyProjectDirs(ctx)
		if dependencyProjectDirErr != nil {
			buildError = dependencyProjectDirErr
			return
		}

		outputDirectories := make([]*dagger.Directory, len(dependencyDirNames))
		for i, dependencyProjectDir := range dependencyDirNames {
			// Syncronously wait for each dependency to build,
			// because top-level has already kicked off each project
			triggerProjectBuildGroup(dependencyProjectDir)
			if buildError != nil {
				return
			}
			mapMutex.RLock()
			outputDirectories[i] = builtProjects[dependencyProjectDir].directory
			mapMutex.RUnlock()
		}

		if buildError != nil {
			return
		}

		directory := <%= it.changeCase.camelCase(it.dagger.name) %>Builder.BuildProject(
			projectDir,
			outputDirectories,
		<% for (const arg of [...it.constructorArguments.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
			<%= arg.name %>,
		<% } %>
		)

		mapMutex.Lock()
		defer mapMutex.Unlock()
		project := builtProjects[projectDir]
		project.directory = directory
		builtProjects[projectDir] = project
	}
	triggerProjectBuildGroup = func(projectDir string) {
		mapMutex.RLock()
		projectOnce := builtProjects[projectDir].once
		mapMutex.RUnlock()
		// Only run project build once, reporting wait/error groups
		projectOnce.Do(func() {
			defer waitGroup.Done()
			triggerProjectBuild(projectDir)
		})
	}

	for _, projectDir := range projectDirs {
		// kick off building for each project
		triggerProjectBuildGroup(projectDir)
	}

	waitGroup.Wait()
	if buildError != nil {
		return nil, buildError
	}

	response := dag.Directory()
	for projectDir, project := range builtProjects {
		response = response.WithDirectory(
			projectDir,
			project.directory,
		)
	}

	return response, nil
}