// Code generated by nx-dagger. DO NOT EDIT.
package main

import (
	"dagger/<%= it.dagger.name %>-builder/internal/dagger"

<% if (it.conditionals.hasCi) { %>
	"context"
<% } %>
	"errors"

	"golang.org/x/sync/errgroup"
)

type <%= it.changeCase.pascalCase(it.dagger.name) %>Builder struct {
	// Root of source file
	Source *dagger.Directory
}

func New(
	// Root of source file
	source *dagger.Directory,
) *<%= it.changeCase.pascalCase(it.dagger.name) %>Builder {
	return &<%= it.changeCase.pascalCase(it.dagger.name) %>Builder{
		Source: source,
	}
}

type NxProjectRuntime string

const (
<% for (const runtime of [...it.runtimes.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	_runtime_<%= it.changeCase.camelCase(runtime.name) %> NxProjectRuntime = "<%= runtime.name %>"
<% } %>
)

type NxProjectDir string

const (
<% for (const project of [...it.projects.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	_project_<%= it.changeCase.camelCase(project.name) %> NxProjectDir = "<%= project.directory %>"
<% } %>
)

type NxTarget string

const (
<% for (const target of [...it.targets.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	_target_<%= it.changeCase.camelCase(target.name) %> NxTarget = "<%= target.name %>"
<% } %>
)

type NxProject struct {
	runtime                     NxProjectRuntime
	dependencyProjectDirs       []NxProjectDir
	directDependencyProjectDirs []NxProjectDir
	targets                     []NxTarget
}

var nxConfig = map[NxProjectDir]NxProject{
<% for (const project of [...it.projects.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	_project_<%= it.changeCase.camelCase(project.name) %>: {
		runtime:                     _runtime_<%= it.changeCase.camelCase(it.runtimes.get(project.runtime).name) %>,
		dependencyProjectDirs:       []NxProjectDir{
		<% for (const dependency of project.dependencies) { %>
			_project_<%= it.changeCase.camelCase(it.projects.get(dependency).name) %>,
		<% } %>
		},
		directDependencyProjectDirs: []NxProjectDir{
		<% for (const dependency of project.directDependencies) { %>
			_project_<%= it.changeCase.camelCase(it.projects.get(dependency).name) %>,
		<% } %>
		},
		targets:                     []NxTarget{
		<% for (const target of project.targets) { %>
			_target_<%= it.changeCase.camelCase(it.targets.get(target).name) %>,
		<% } %>
		},
	},
<% } %>
}

// List all project directories, filtered by runtime
// Empty string results in all project directories
func (m *<%= it.changeCase.pascalCase(it.dagger.name) %>Builder) ProjectDirs(runtime string) []string {

	results := []string{}

	for projectDir, config := range nxConfig {
		if runtime == "" || runtime == string(config.runtime) {
			results = append(results, string(projectDir))
		}
	}

	return results
}


type ProjectConfig struct {
	Runtime                     string
	DependencyProjectDirs       []string
	DirectDependencyProjectDirs []string
	Targets                     []string
}

// Load config settings for the provided project directory
func (m *<%= it.changeCase.pascalCase(it.dagger.name) %>Builder) ProjectConfig(projectDir string) ProjectConfig {

	config := nxConfig[NxProjectDir(projectDir)]
	stringDependencyProjectDirs := make([]string, len(config.dependencyProjectDirs))
	stringDirectDependencyProjectDirs := make([]string, len(config.directDependencyProjectDirs))
	stringTargets := make([]string, len(config.targets))

	for i, dependencyProjectDir := range config.dependencyProjectDirs {
		stringDependencyProjectDirs[i] = string(dependencyProjectDir)
	}
	for i, directDependencyProjectDir := range config.directDependencyProjectDirs {
		stringDirectDependencyProjectDirs[i] = string(directDependencyProjectDir)
	}
	for i, target := range config.targets {
		stringTargets[i] = string(target)
	}

	return ProjectConfig{
		Runtime:                     string(config.runtime),
		DependencyProjectDirs:       stringDependencyProjectDirs,
		DirectDependencyProjectDirs: stringDirectDependencyProjectDirs,
		Targets:                     stringTargets,
	}
}

func (m *<%= it.changeCase.pascalCase(it.dagger.name) %>Builder) BuildProject(
<% if (it.conditionals.hasCi) { %>
	ctx context.Context,
<% } %>
	projectDirStr string,
	dependencyDirectories []*dagger.Directory,
<% for (const arg of [...it.constructorArguments.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
	<%= arg.name %> <%= arg.type %>,
<% } %>
) (*dagger.Directory, error) {

    projectDir := NxProjectDir(projectDirStr)
<% if (it.conditionals.hasDependencyProjectDirs) { %>
	dependencyProjectDirs := make([]string, len(nxConfig[projectDir].dependencyProjectDirs))
<% } %>
<% if (it.conditionals.hasDirectDependencyProjectDirs) { %>
	directDependencyProjectDirs := make([]string, len(nxConfig[projectDir].directDependencyProjectDirs))
<% } %>
<% if (it.conditionals.hasOutput) { %>
	output := dag.Directory()
<% } %>
<% if (it.conditionals.hasDependencyProjectDirs || it.conditionals.hasOutput) { %>
	for i, directoryName := range nxConfig[projectDir].dependencyProjectDirs {
    <% if (it.conditionals.hasDependencyProjectDirs) { %>
		dependencyProjectDirs[i] = string(directoryName)
    <% } %>
    <% if (it.conditionals.hasOutput) { %>
		output = output.WithDirectory(string(directoryName), dependencyDirectories[i])
    <% } %>
	}
<% } %>
<% if (it.conditionals.hasDirectDependencyProjectDirs) { %>
	for i, directory := range nxConfig[projectDir].directDependencyProjectDirs {
		directDependencyProjectDirs[i] = string(directory)
	}
<% } %>
<% if (it.conditionals.hasProjectSource) { %>
	projectSource := m.Source.Directory(string(projectDir))
<% } %>

	var built *dagger.Directory
	switch nxConfig[projectDir].runtime {
	<% for (const runtime of [...it.runtimes.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
		case _runtime_<%= it.changeCase.camelCase(runtime.name) %>:
			built = dag.<%= it.changeCase.pascalCase(runtime.preBuild.name) %>(
				<% for (const arg of runtime.preBuild.constructorArguments) { %>
					<%= it.constructorArguments.get(arg).name %>,
				<% } %>
			).Run(
			<% for (const parameter of runtime.preBuild.parameters) { %>
				<%= it.parametersMap[parameter] %>,
			<% } %>
			)
	<% } %>
		default:
			return nil, errors.New("No matching runtime: " + string(nxConfig[projectDir].runtime))
	}

	ciErrors, cancelCtx := errgroup.WithContext(ctx)

	for _, target := range nxConfig[projectDir].targets {

		switch target {
		<% for (const target of [...it.targets.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
			case _target_<%= it.changeCase.camelCase(target.name) %>:
			<% if (target.isCi) { %>
				ciErrors.Go(func() error {
					return dag.<%= it.changeCase.pascalCase(target.name) %>(
						<% for (const arg of target.constructorArguments) { %>
							<%= it.constructorArguments.get(arg).name %>,
						<% } %>
					).Ci(
						cancelCtx,
					<% for (const parameter of target.parameters) { %>
						<%= it.parametersMap[parameter] %>,
					<% } %>
					)
				})
			<% } else { %>
				built = dag.<%= it.changeCase.pascalCase(target.name) %>(
					<% for (const arg of target.constructorArguments) { %>
						<%= it.constructorArguments.get(arg).name %>,
					<% } %>
				).Run(
					<% for (const parameter of target.parameters) { %>
						<%= it.parametersMap[parameter] %>,
					<% } %>
				)
			<% } %>
		<% } %>
			default:
				return nil, errors.New("No matching target executor: " + string(target))
		}
	}

	if err := ciErrors.Wait(); err != nil {
		return nil, err
	}

	switch nxConfig[projectDir].runtime {
	<% for (const runtime of [...it.runtimes.values()].sort((a, b) => a.name.localeCompare(b.name, 'en'))) { %>
		case _runtime_<%= it.changeCase.camelCase(runtime.name) %>:
			built = dag.<%= it.changeCase.pascalCase(runtime.postBuild.name) %>(
				<% for (const arg of runtime.postBuild.constructorArguments) { %>
					<%= it.constructorArguments.get(arg).name %>,
				<% } %>
			).Run(
			<% for (const parameter of runtime.postBuild.parameters) { %>
				<%= it.parametersMap[parameter] %>,
			<% } %>
			)
	<% } %>
		default:
			return nil, errors.New("No matching runtime: " + string(nxConfig[projectDir].runtime))
	}

	return built, nil
}
