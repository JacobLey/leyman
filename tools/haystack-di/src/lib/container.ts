import pDefer, { type DeferredPromise } from 'p-defer';
import type {  GenericBinding } from '#binding';
import { 
    HaystackSyncSupplierError,
    HaystackCircularDependencyError,
    HaystackInstanceOfResponseError,
    HaystackMultiError,
    HaystackNullResponseError,
    HaystackProviderMissingError,
    HaystackUndefinedResponseError,
} from '#errors';
import { type GenericHaystackId, type HaystackId, type HaystackIdType, type StripAnnotations, unsafeIdentifier } from '#identifier';
import type { Extendable, InstanceOfClass, InvalidInput, IsClass, NonExtendable } from '#types';
import { Scopes, optimisticRequestScope, optimisticSingletonScope, requestScope, singletonScope, supplierScope, transientScope } from '#scopes';

/**
 * Used during late-binding instantiations, as a way to provide references to
 * "this already exists in request chain, so can re-use it".
 */
type LateCache = Map<GenericBinding, {
    value: unknown;
}>;
/**
 * Cached values for scope, to prevent re-instantiations.
 * 
 * Async version will rely on the `promise`, which will resolve to the `value`.
 * Sync version will just rely on the `value` and populate an auto-resolving promise
 * (and we generally protect against the possibility that sync version will try to access value before populated).
 * 
 * Note that the `promise` wraps the value in a tuple, in order to prevent accidentally merging with the raw value
 * in the case that it is a promise itself (not a recommended pattern, but supported nonetheless).
 */
type ScopeCache = Map<GenericBinding, {
    promise?: Promise<readonly [unknown]>;
    value?: unknown;
}>;
/**
 * Generated by a binding to bubble up to top-level request.
 * Extends a deferred promise that is expected to be resolved with the late-bound value, or rejected
 * with any errors that pop up in the meantime.
 * 
 * The registry will be populated by instances that are created in the chain, so that _eventually_ that value
 * can be re-used when requested during late binding.
 */
interface LateBindingRequest extends DeferredPromise<unknown> {
    binding: GenericBinding;
    dependencyId: GenericHaystackId;
    registry: LateCache;
}

type NoBindingDeclared = [InvalidInput<'NoBindingDeclared'>];

declare const typeTracking: unique symbol;
const createContainerSym = Symbol('createContainer');
const preloadSyncSym = Symbol('preloadSync');
const getSyncSym = Symbol('getSync');

/**
 * Container that will be wired to generate instances on demand.
 * Supports async providers externally, and sync providers internally
 * (either via suppliers or the extended {@link SyncContainer} class).
 * 
 * Type declarations on the class are based on all the possible allowed inputs
 * (e.g. if based on a binding of Foo, there are entries for both Foo + Foo | null).
 * 
 * This typing should be considered an internal implementation, and not hard-coded in
 * any way.
 * 
 * Instances of containers are not created directly, and should be implemented via `createContainer`
 * which will use an underlying `Module` and perform the necessary checks to ensure that all
 * necessary bindings exist.
 * 
 * Using a container comes in four steps.
 * 1) Checking
 *    - Optional step, although produces potentially unsafe code. 
 *    - Should only be skipped if checks are performed elsewhere (e.g. during unit tests).
 * 2) Wiring
 *    - Sets up the actual data flow to generate instances based on scopes and suppliers.
 *    - Will perform checks, if not explicitly performed already
 * 3) Preload
 *    - Instantiates any optimistic singletons
 *    - Will perform wiring, if not explicitly performed already
 * 4) Get
 *    - Main use case of container. Used for actual instantiation, and can be used to continue to create more instances.
 *    - Will perform preload, if not explicitly performed already.
 */
export class AsyncContainer<Outputs extends [Extendable]> {

    declare private [typeTracking]: Outputs;
    #isSync: boolean;
    #bindings: readonly GenericBinding[];
    #baseIdToBinding: ReadonlyMap<GenericHaystackId, GenericBinding>;

    protected constructor(
        protected readonly idToBinding: ReadonlyMap<GenericHaystackId, GenericBinding>
    ) {
        this.#bindings = [...new Set(idToBinding.values())];
        this.#baseIdToBinding = new Map(this.#bindings.map(binding => [binding.outputId.baseId(), binding]));
        this.#isSync = this.#bindings.every(binding => !binding.isAsync);
    }

    /**
     * Exposed to module to create container in protected type-safe way.
     * @param bindings module bindings
     * @returns container
     */
    public static [createContainerSym]<Outputs extends [Extendable]>(bindings: ReadonlyMap<GenericHaystackId, GenericBinding>) {
        return new AsyncContainer<Outputs>(bindings);
    }

    #checked = false;
    /**
     * Check internals of container to protect against edge cases that cannot be protected against via traditional type safety.
     * 
     * Can safely be called multiple times, and will immediately short circuit successfully after the first.
     * 
     * The checks performed are:
     * * Ensuring all dependencies have a binding
     *   * Ideally module logic protect against this, but it is possible to accidentially re-instantiate an identifier, or to
     *     have classes that _should_ be treated separately, but actually are exact matches in Typescript's duck typing.
     * * Protect Circular dependencies
     *   * Circular dependencies can be tricky to see directly, as they may be the result of large chains including suppliers.
     *     The type system does not attempt to protect against circulars for this reason, so a check must be performed to ensure
     *     either no circulars exist, or they are properly protected against with late bindings and properly scoped suppliers.
     * * Enforce circular suppliers
     *   * The top level container will always be async if a single provider internally is async. However the suppliers generated internally
     *     _may_ be sync, if just that dependency path is all sync. The type system is not able to track this directly, because there are
     *     cases of async dependencies that can be treated as sync, because optimistic scoping will pre-cache the value.
     */
    public check() {
        if (this.#checked) {
            return;
        }
        this.#checkForDependenciesOutput();
        this.#checkForCircular();
        this.#checkForAsyncSupplier();

        this.#checked = true;
    }

    /**
     * Check that every dependency declared in bindings has an equivalent binding declared.
     * 
     * For the most part, we are protected against this by strongly-typed modules and container creation, but there are ways to
     * accidentally get around this.
     * 
     * The two main ways that type safety may fail (so this check still neeeds to exist):
     * * Accidentally redefining the same identifier. 
     *   * The issue arises from `identifier() !== identifier()`. 
     *     So even if the exact same types/names are provided, the actual values seen by javascript are different.
     *   * note classes are generally protected from this (`identifier(Foo) === identifier(Foo)`) but can still result in other errors (see second point).
     * * Using class constructors for instances that are exact matches via duck-typing.
     *   * According to typescript, classes that have the exact same interface are replaceable with eachother. 
     *     Often times this is actually desired behavior, but can result in unexpected behavior.
     *     ```
     *     class Foo {
     *         similarValue: 123;
     *     }
     *     class Bar {
     *         similarValue: 123;
     *     }
     *     // Legal!
     *     const x: Foo = new Bar();
     *     ```
     *     As a result, haystack cannot tell the difference between `identifier(Foo)` and `identifier(Bar)`.
     */
    #checkForDependenciesOutput(): void {
        const uniqueDependencyIds =// depdupeEffectiveBaseId(
            new Set(this.#bindings.flatMap(binding => binding.dependencyIds.map(id => id.lateBinding(false).supplier(false))))
        ;

        const noProviderFoundIds: GenericHaystackId[] = [];

        for (const dependencyId of uniqueDependencyIds) {
            if (!this.idToBinding.has(dependencyId)) {
                noProviderFoundIds.push(dependencyId);
            }
        }

        if (noProviderFoundIds.length > 0) {
            throw new HaystackProviderMissingError(noProviderFoundIds);
        }
    }

    /**
     * Flag any instances of "illegal" circular dependencies, and throw an error.
     * 
     * Circular bindings are defined as cases where in order to create dependency `A`, 
     * Haystack must first provide it with an instance of `A` (either directly, or via the chain of sub-dependencies)
     * 
     * This is naively impossible, and results in infinite requests for `A`, even if using a scope that
     * can take advantage of caching (because the original request can never return to populate the cache).
     * 
     * The best solution is to simply avoid circular dependencies in design.
     * 
     * The next best is to utilize "late-binding". This means the dependency is on a promise that _eventually_ resolves to
     * the requested value.
     * 
     * For non-supplier dependencies, late-binding successfully "breaks the chain".
     * 
     * e.g. `A` depends on `B` depends on `C` depends on `D`, which _circularly_ depends on `A`. 
     * Making any single of these dependencies late-binding is enough.
     * 
     * For supplier dependencies, this may not be enough.
     * 
     * e.g. `A` depends on `B`. `B` depends on late-binding `C`. `C` depends on a supplier of `D`. `D` depends on `A`.
     * 
     * In order to supply the instance of `C` to `B`, we need to create a supplier of `D`. This _supplier_ can _theoretically_ be used
     * immediately in the provider, which instantiates a _new_ request for `D` (which requests `A`, and `B`!).
     * 
     * This is the infinite loop we were trying to avoid.
     * 
     * Suppliers are only allowed in a circular dependency when a binding in the chain has a scope that can re-use a previously cached value.
     * That means either a singleton scope, or request scope with propagation.
     * 
     * In the example above, if the supplier propagated scope and `B` had been `request scope`d, it would be valid. 
     * This is because newly "supplied" instaces of D could fall back on cached version of B instead of re-instanting and infinitely looping.
     * 
     * In order to detect these circular dependencies, perform a check for each individual binding.
     * Iterate over each dependency, tracking the current "chain".
     * 
     * If we end at a binding with no dependencies, that "chain" is safe.
     * If we end up at a dependency that is _already_ in the chain, end this check (if it is illegally circular, let that binding perform its own check).
     * If we end up at a dependency of our original binding:
     *     * If we never crossed a late-binding boundary, flag this as circular
     *     * Else
     *          * If there is a singleton-scoped in the chain, it is safe
     *          * If there is a request-scoped in the chain
     *              * If never crossed a non-propagating supplier boundary, it is safe
     *              * else flag this is as circular
     * 
     * We can optimize the _safe_ paths a bit.
     * If we know `A` is not flagged as a circular, then any time `A` comes up in the check, we can immediately declare the chain safe.
     * However we cannot do the same for _unsafe_ paths (which matters less, since performance in the case that eventually throws and error is less important).
     * 
     * example: `A` depends on `B`, `B` depends on `C`, and `C` depends on `B`.
     * Both `B` and `C` are unsafe circulars. However this is not `A`'s fault, and should be excluded from the reporting.
     */
    #checkForCircular(): void {

        const safeBindings = new Set<GenericBinding>();
        const circularPaths: GenericHaystackId[][] = [];
        const singletonScopes = new Set([optimisticSingletonScope, singletonScope]);
        const requestScopes = new Set([optimisticRequestScope, requestScope]);

        const isChainSafe = (chain: GenericHaystackId[]): boolean => {
            if (chain.some(dependencyId => dependencyId.annotations.lateBinding)) {
                // Only if there is late binding can circular dependencies be acceptable
                const bindingChain = chain.map((dependencyId, i) => ({
                    // We want the _next_ dependency in the chain, that is declared by 
                    // _this_ dependency's binding
                    dependencyId: chain[(i + 1) % chain.length]!,
                    binding: this.#baseIdToBinding.get(dependencyId.baseId())!,
                }));

                if (bindingChain.some(({ binding }) => singletonScopes.has(binding.scope))) {
                    // Singletons will eventually run into cached value, so are safe (regardless of suppliers)
                    return true;
                }

                if (bindingChain.some(({ binding }) => requestScopes.has(binding.scope))) {
                    // Request scopes are safe _only_ if the scope is propagated the entire way.
                    return bindingChain.every(({ binding, dependencyId }) => {
                        const { supplier } = dependencyId.annotations;
                        if (supplier) {
                            return supplier.propagateScope && binding.scope !== supplierScope;
                        }
                        return true;
                    });
                }

                // If there are no suppliers, this is safe
                return bindingChain.every(({ dependencyId }) => !dependencyId.annotations.supplier);
            }
            return false;
        };

        const isBindingSafe = (
            outputId: GenericHaystackId, 
            dependencyChain: Set<GenericHaystackId>
        ): boolean => {

            const binding = this.#baseIdToBinding.get(outputId.baseId())!;

            if (safeBindings.has(binding)) {
                return true;
            }

            if (dependencyChain.has(outputId)) {
                let foundCircular = false;
                const circularChain = [...dependencyChain].filter(id => {
                    if (id === outputId) {
                        foundCircular = true;
                    }
                    return foundCircular;
                });
                if (isChainSafe(circularChain)) {
                    return true;
                }
                circularPaths.push(circularChain);
                return false;
            }
            dependencyChain.add(outputId);

            let isSafe = true;
            for (const dependencyId of binding.dependencyIds) {
                isSafe = isBindingSafe(
                    dependencyId,
                    new Set(dependencyChain)
                ) && isSafe;
            }
            return isSafe;
        };

        for (const binding of this.#bindings) {
            if (isBindingSafe(
                binding.outputId,
                new Set(),
            )) {
                safeBindings.add(binding);
            }
        }

        if (circularPaths.length > 0) {
            throw new HaystackCircularDependencyError(circularPaths);
        }
    }

    /**
     * Suppliers are by default synchronous, even if the underlying container is async
     * (although they can be flagged async to avoid this issue altogether).
     * 
     * A supplier can be sync when the binding is synchronous and every dependency qualifies as synchronous.
     * It can also be synchronous if async binding or dependencies can utilize optimistic scopes.
     * 
     * Note that late-binding does not "protect" a binding from async dependencies.
     * This is because late-bindings will resolve by the time the request completes 
     * (or rather, immediately on the next event loop, which is the best we can do with promises).
     * So a late-binding dependency must resolve syncronously as well.
     * 
     * Suppliers that propagate their scope (and are not supplier-scoped themselves) can benefit from optimistic request bindings, 
     * but ones that do not can only rely on optimistic singletons.
     * 
     * We only need to inspect sync suppliers 
     * (async suppliers don't have this problem, and regular bindings can obfuscate the instantation logic, the whole point of DI)
     * to see if the dependency chain is safe.
     * 
     * Some optimizations can be performed to prevent duplicate checks against suppliers. 
     * (e.g. both Foo + Bar has dependency on supplier of Baz can re-use the same calculation)
     */
    #checkForAsyncSupplier() {

        const isSafeForSync = (
            binding: GenericBinding, 
            chain: Set<GenericHaystackId>,
            optimisticScopes: Set<Scopes>
        ): boolean => {
            const baseId = binding.outputId.baseId();
            if (chain.has(baseId)) {
                // Part of circular dependency.
                // If we are sync up until this point, it can remain sync.
                return true;
            }
            if (optimisticScopes.has(binding.scope)) {
                // If the "parent" scopes have already optimistically created these resources, 
                // will be synchronously available
                return true;
            }
            if (binding.isAsync) {
                // Value cannot guaranteed to be present, even if belonging to "parent" scope.
                return false;
            }
            return binding.dependencyIds.every(dependencyId => {
                const { supplier } = dependencyId.annotations;
                if (
                    supplier
                    && (
                        !supplier.propagateScope
                        || !supplier.sync
                    )
                ) {
                    // Either async boundary or separate request.
                    // Separate requests are validated in separate iteration
                    return true;
                }
                // Continue checking dependencies
                return isSafeForSync(
                    this.#baseIdToBinding.get(dependencyId.baseId())!,
                    new Set([...chain, baseId]),
                    optimisticScopes,
                );
            });
        };

        const syncSuppliers = this.#bindings.flatMap(binding => binding.dependencyIds.map(id => [binding, id] as const))
            .filter(([binding, dependencyId]) => {
                const { supplier } = dependencyId.annotations;
                return supplier && supplier.sync; 
            });
            
        const safeBindings = new Set<GenericBinding>();
        const unsafeBindings = new Set<GenericBinding>();
        const unsafeSupplierBindings: {
            bindingOutputId: GenericHaystackId;
            supplierId: GenericHaystackId;
        }[] = [];
        const addUnsafePair = (dependencyBinding: GenericBinding, propagateScope: boolean) => {
            const dependencyBaseId = dependencyBinding.outputId.baseId();
            for (const binding of this.#bindings) {
                for (const depId of binding.dependencyIds) {
                    if (depId.baseId() === dependencyBaseId) {
                        const { supplier } = depId.annotations;
                        if (supplier && supplier.sync && supplier.propagateScope === propagateScope) {
                            unsafeSupplierBindings.push({
                                bindingOutputId: dependencyBinding.outputId, 
                                supplierId: depId,
                            });
                        }
                    }
                }
            }
        }

        for (const [propagateScope, isSupplierScope, optimisticScopes] of [
            // Suppliers that are the "entrypoint" for a request cannot rely on optimistic requests
            // to pre-cache async dependencies.
            [false, false, new Set([optimisticSingletonScope] as const)],
            [false, true, new Set([optimisticSingletonScope] as const)],
            // Suppliers that are _not_ the "entrypoint", but are not inheriting the original request scope cannot rely
            // on optimistic requests to pre-cache async dependencies.
            [true, true, new Set([optimisticSingletonScope] as const)],
            // Suppliers that are the propagating scope from a parent request _can_ rely on optimistic requests
            // to pre-cache async dependencies.
            [true, false, new Set([optimisticRequestScope, optimisticSingletonScope] as const)]
        ] as const) {

            const syncBindings = new Set(
                syncSuppliers
                    .filter(([, id]) => (id.annotations.supplier as { propagateScope: boolean }).propagateScope === propagateScope)
                    .filter(([binding]) => (binding.scope === supplierScope) === isSupplierScope)
                    .map(([, id]) => this.#baseIdToBinding.get(id.baseId())!)
                    .filter(binding => !safeBindings.has(binding) && !unsafeBindings.has(binding))
            );

            for (const syncBinding of syncBindings) {
                if (isSafeForSync(
                    syncBinding, 
                    new Set(), 
                    optimisticScopes
                )) {
                    safeBindings.add(syncBinding);
                } else {
                    unsafeBindings.add(syncBinding);
                    addUnsafePair(syncBinding, propagateScope);
                };
            }
        }

        if (unsafeSupplierBindings.length > 0) {
            throw new HaystackSyncSupplierError(unsafeSupplierBindings);
        }
    }

    #wired = false;
    /**
     * Pre-calculate paths for requests to take, so that the actual requests to the container can be determined immediately.
     * Does not actually perform any instantiations.
     * 
     * Can safely be called multiple times, and will immediately short circuit successfully after the first.
     * 
     * Calls check internally, to ensure container is in a healthy state before continuing.
     * 
     * The wiring performed is:
     * * Optimistic Singletons
     *   * Optimistic singletons are tricky becuase despite their _potentially_ async nature, it is always safe to treat them as
     *     sync in other parts of requests. During the very beginning of initialization though, that is not necessarily safe,
     *     so calculate the dependency order in which singletons can be instantiated without causing issues.
     * * Optimistic Requests
     *   * Similar to singletons, optimistic requests can potentially be treated as sync. Again we need to ensure the values
     *     are constructed in the right order to safely access. Also ensures we _only_ optimistically instantiate providers
     *     relevant to this top-level request.
     * * Determine which dependencies are safe for async
     *   * Where possible, we want to use synchronous instantiation. The logic is overall simpler and more performant. However,
     *     it is not clear based on the binding alone whether or not an instantion can be done syncronously (e.g. has async dependencies)
     *     so this is pre-calculated.
     */
    public wire(): void {
        if (this.#wired) {
            return;
        }

        this.check();

        this.#wireSingletons();
        this.#wireRequests();
        this.#wireAsyncs();

        this.#wired = true;
    }

    #singletonMap = new Map<GenericBinding, GenericBinding[]>();
    /**
     * Precalcuate list of optimistic singletons that need to be instantiated, before 
     * the specified optimistic singleton can be instantiated.
     * 
     * Only populates entries for optimistic singletons, so possible resulting map is actually empty or
     * has no dependencies declared.
     * 
     * Does not actually perform the instantations.
     */
    #wireSingletons(): void {

        const collectBindings = (binding: GenericBinding, stack: Set<GenericHaystackId>): GenericBinding[] => {

            if (stack.has(binding.outputId.baseId())) {
                return [];
            }

            const collected: GenericBinding[] = [];
            for (const dependencyId of binding.dependencyIds) {
                const { lateBinding, supplier } = dependencyId.annotations;
                if (
                    lateBinding ||
                    (
                        supplier 
                        && !supplier.sync
                    )
                ) {
                    continue;
                }
                const dependencyBinding = this.#baseIdToBinding.get(dependencyId.baseId())!;
                if (dependencyBinding.scope === optimisticSingletonScope) {
                    collected.push(dependencyBinding);
                } else {
                    collected.push(...collectBindings(dependencyBinding, new Set([...stack, dependencyId.baseId()])));
                }
            }
            return collected;
        };

        for (const binding of this.#bindings.filter(binding => binding.scope === optimisticSingletonScope)) {
            this.#singletonMap.set(
                binding,
                [...new Set(collectBindings(binding, new Set()))]
            );
        }
    }

    #requestMap = new Map<GenericBinding, GenericBinding[]>();
    /**
     * Map of binding being requested, to bindings that need to be optimisitcally instantiated first.
     * 
     * Applies to both top-level requests, and suppliers that do not propagate scope.
     * (Suppliers that do propagate scope don't need to re-instantiate anything)
     * 
     * Will contain entries for every request. This ensures that no extra values are instantiated during
     * a request that are not related to the dependency graph.
     * 
     * Does not actually perform the instantiations.
     */
    #wireRequests(): void {
        const collectBindings = (binding: GenericBinding, stack: Set<GenericHaystackId>): GenericBinding[] => {

            if (stack.has(binding.outputId.baseId())) {
                return [];
            }

            const collected: GenericBinding[] = [];
            for (const dependencyId of binding.dependencyIds) {

                const dependencyBinding = this.#baseIdToBinding.get(dependencyId.baseId())!;
                if (dependencyBinding.scope === optimisticSingletonScope) {
                    continue;
                } else if (dependencyBinding.scope === optimisticRequestScope) {
                    collected.push(dependencyBinding);
                } else {
                    collected.push(...collectBindings(dependencyBinding, new Set([...stack, dependencyId.baseId()])));
                }
            }
            return collected;
        };
        for (const binding of this.#bindings) {
            this.#requestMap.set(
                binding,
                [...collectBindings(binding, new Set())]
            );
        }
    }

    #isAsyncImplementationMap = new Map<GenericBinding, boolean>();
    /**
     * Calculate whether any binding can be performed syncronously.
     * 
     * This mapping is only checked during the async path, as we _prefer_ the sync path for simplicity and performance.
     * The sync path cannot possibly redirect the the async path, so there are checks the protect against that need.
     * 
     * Note that whether or not the binding is being referenced via a top-level request, a provider dependency,
     * a late binding request, or a supplier is irrelevant to the logic here.
     * 
     * The main difference between enabling sync for suppliers has to do with ability to use request caching,
     * but for the actual provider instantiation the request singletons will already exist regardless of context.
     */
    #wireAsyncs() {
        const optimisticScopes = new Set([optimisticRequestScope, optimisticSingletonScope]);
        const isAsync = (binding: GenericBinding, chain = new Set<GenericBinding>()): boolean => {
            if (chain.has(binding)) {
                // Come full circle. If nothing in the chain has forced async yet, we can stay sync
                return false;
            }
            const existing = this.#isAsyncImplementationMap.get(binding);
            if (typeof existing === 'boolean') {
                // Try to re-use solved portions when available
                return existing;
            }
            if (binding.isAsync) {
                // This is the only that that actually forces async implementations,
                // but can force all consumers, including seemingly sync proiders depending on late-bindings
                this.#isAsyncImplementationMap.set(binding, true);
                return true;
            }
            return binding.dependencyIds.some(dependencyId => {
                if (dependencyId.annotations.supplier) {
                    // Suppliers are resolved "immediately" so that is sync
                    return false;
                }
                const dependencyBinding = this.#baseIdToBinding.get(dependencyId.baseId())!;
                if (optimisticScopes.has(dependencyBinding.scope)) {
                    // Optimistic values are pre-computed, so the actual request can always rely on cache
                    return false;
                }
                // Check dependency, appending to chain
                return isAsync(dependencyBinding, new Set([...chain, binding]));
            });
        };

        for (const binding of this.#bindings) {
            this.#isAsyncImplementationMap.set(binding, isAsync(binding));
        }
    }

    #singletonCache: ScopeCache = new Map();

    /**
     * Asynchronously instantiate a binding. Will create all dependencies first before invoking provider.
     * Supplier will be implemented as as a new internal request for that binding, potentially propagating request scope.
     * Late bindings will be implemented as a deferred promise that will be handled by the top-level request 
     * (which will iteratively instantiate each dependency and resolve/reject as necessary).
     * 
     * @param binding binding being requested
     * @param requestCache current request cache, shared across entire request
     * @param supplierCache current scope cache, potentially same as requestCache, 
     *                      but should be treated differently based on supplier context and scope
     * @param lateBindingCache map of any bindings that have been calculated already in the current request chain, 
     *                         which should be re-used if possible.
     * @returns promise of both the instantiated value, and any late binding requests that have been generated by dependencies 
     *         (and dependencies of dependencies)
     */
    async #getImplementation(binding: GenericBinding, requestCache: ScopeCache, supplierCache: ScopeCache, lateBindingCache: LateCache): Promise<{
        value: unknown;
        lateBindingRequests: LateBindingRequest[];
    }> {

        // If already created instance in same dependency chain, just re-use that one!
        const lateBindingValue = lateBindingCache.get(binding);
        if (lateBindingValue) {
            return {
                value: lateBindingValue.value,
                lateBindingRequests: [],
            };
        }

        const relevantCache = {
            [transientScope]: null,
            [optimisticSingletonScope]: this.#singletonCache,
            [singletonScope]: this.#singletonCache,
            [optimisticRequestScope]: requestCache,
            [requestScope]: requestCache,
            [supplierScope]: supplierCache,
        }[binding.scope];

        // If an instance already exists (or is being created in parallel) in the same request, return that immediately.
        // **NOTE** It is very important that any code that exists between here and the "write to cache" later down
        // is _synchronous_ to prevent any possible race condition between requests and their scoping.
        // Promises generated in the middle will be collected and awaited afterwards.
        if (relevantCache) {
            const cached = relevantCache.get(binding);
            if (cached) {
                const [value] = await cached.promise!;
                return {
                    value: value,
                    lateBindingRequests: [],
                };
            }
        }

        // Create the value that will be put in cache immediately. Will be necessary to check during late binding rejections
        // to safely evict from cache.
        const cacheContainer = {};

        const lateBindingRequests: LateBindingRequest[] = [];

        // Setup a collection of promises that will be extended by every late binding.
        // Will be used later during the caching to ensure the cache can't resolve until the late-bindings resolve.
        const lateBindingPromises: Promise<unknown>[] = [];

        // Collect a promise that will resolve with the (wrapped) value, but don't actually 
        // await it until we get the cache setup.
        const outputPromise = (async () => {
            const settled = await Promise.allSettled(
                binding.dependencyIds.map(async (dependencyId): Promise<readonly [unknown]> => {
                    const { lateBinding, supplier } = dependencyId.annotations;
                    if (lateBinding) {
                        const deferred = pDefer();
                        lateBindingPromises.push(deferred.promise);
                        const registry: LateCache = new Map();
                        lateBindingRequests.push({
                            ...deferred,
                            binding,
                            dependencyId,
                            registry,
                        });
                        return [deferred.promise];
                    } 

                    const dependencyBinding = this.#baseIdToBinding.get(dependencyId.baseId())!;
                    
                    if (supplier) {
                        // If we propagate scope, we need to ensure we are propagating the "selected" scope for this binding
                        const passedCache: ScopeCache = binding.scope === supplierScope ? supplierCache : requestCache;
                        if (supplier.sync) {
                            return [() => {
                                const scopeCache = new Map();
                                return this.#getSync(
                                    dependencyBinding, 
                                    supplier.propagateScope ? passedCache : scopeCache,
                                    scopeCache
                                );
                            }];
                        } else {
                            return [async () => {
                                const scopeCache = new Map();
                                return this.#getMaybeSync(
                                    dependencyBinding, 
                                    supplier.propagateScope ? passedCache : scopeCache,
                                    scopeCache
                                );
                            }];
                        }
                    } else {
                        // Attempt to generate dependencies syncronously _if possible_ for both performance optimizations,
                        // and to help prevent race conditions.
                        const dependency = this.#isAsyncImplementationMap.get(dependencyBinding)!
                            ? await this.#getImplementation(dependencyBinding, requestCache, supplierCache, lateBindingCache)
                            : this.#getSyncImplementation(dependencyBinding, requestCache, supplierCache, lateBindingCache);
                        lateBindingRequests.push(...dependency.lateBindingRequests);
                        return [dependency.value];
                    }
                })
            );

            HaystackMultiError.validateAllSettled(settled);

            const dependencies = settled.flatMap(settle => settle.value);
            const value = binding.isAsync
                ? await binding.provider(...dependencies)
                : binding.provider(...dependencies);

            if (value === null) {
                if (!binding.outputId.annotations.nullable) {
                    throw new HaystackNullResponseError(binding.outputId);
                }
            } else if (value === undefined) {
                if (!binding.outputId.annotations.undefinable) {
                    throw new HaystackUndefinedResponseError(binding.outputId);
                }
            } else if (binding.outputId.construct) {
                if (!(value instanceof binding.outputId.construct)) {
                    throw new HaystackInstanceOfResponseError(binding.outputId, value);
                }   
            }

            for (const { registry } of lateBindingRequests) {
                registry.set(binding, { value });
            }
            return [value];
        })();

        // After cache has been written to, we can await any promises that have been initialized.
        if (relevantCache) {
            // Note the cache value does not _immediately_ have `value` attached to it.
            // While risky, this is safe because it will only be accessed by the sync equivalent
            // if this async method was actually generated "optimistically" and therefore fully resolved.
            const cacheValue = Object.assign(cacheContainer, {
                promise: outputPromise.then(async ([value]) => {
                    cacheValue.value = value;
                    await Promise.all(lateBindingPromises);
                    return [value] as const;
                }).catch(err => {
                    // Failures may occur because of late-bindings,
                    // or because the actual generation promise rejects
                    // (which we still have not actually awaited and checked!)
                    // so if that does happen, we need to evict this value from cache.
                    if (relevantCache.get(binding) === cacheContainer) {
                        relevantCache.delete(binding);
                    }
                    throw err;
                }),
            }) as {
                promise: Promise<[unknown]>;
                value: unknown;
            };
    
            relevantCache.set(binding, cacheValue);
        }

        const [value] = await outputPromise;
        
        return {
            value,
            lateBindingRequests,
        };
    }

    /**
     * Synchronous version of `#getImplementation`. For the most part, logic is the same (just without promises)
     * and can defer to documentation in that method for detail.
     * 
     * In general this method is preferred due to simplicitly (no promise race conditions) and to ensure sync support
     * for suppliers.
     * 
     * @param binding binding being requested
     * @param requestCache current request cache
     * @param supplierCache current scope cache
     * @param lateBindingCache map of any bindings that have been calculated already in the current request chain
     * @returns both the instantiated value, and any late binding requests that have been generated by dependencies
     */
    #getSyncImplementation(binding: GenericBinding, requestCache: ScopeCache, supplierCache: ScopeCache, lateBindingCache: LateCache): {
        value: unknown;
        lateBindingRequests: LateBindingRequest[];
    } {

        const lateBindingValue = lateBindingCache.get(binding);
        if (lateBindingValue) {
            return {
                value: lateBindingValue.value,
                lateBindingRequests: [],
            };
        }

        const relevantCache = {
            [transientScope]: null,
            [optimisticSingletonScope]: this.#singletonCache,
            [singletonScope]: this.#singletonCache,
            [optimisticRequestScope]: requestCache,
            [requestScope]: requestCache,
            [supplierScope]: supplierCache,
        }[binding.scope];

        if (relevantCache) {
            const cached = relevantCache.get(binding);
            if (cached) {
                return {
                    value: cached.value,
                    lateBindingRequests: [],
                };
            }
        }

        const cacheContainer = {};

        const parameters: unknown[] = [];
        const lateBindingRequests: LateBindingRequest[] = [];

        for (const dependencyId of binding.dependencyIds) {
            const { lateBinding, supplier } = dependencyId.annotations;
            if (lateBinding) {
                const deferred = pDefer();
                const registry: LateCache = new Map();
                lateBindingRequests.push({
                    ...deferred,
                    binding,
                    dependencyId,
                    registry,
                    // If late bindings fail, need to evict value from cache
                    // as it is not actually fully and safely instantiated.
                    // Note that async version skips this logic, because the cached promise
                    // performs a similar check to wait for late-binding success.
                    reject: relevantCache ? (err => {
                        deferred.reject(err);
                        if (relevantCache.get(binding) === cacheContainer) {
                            relevantCache.delete(binding);
                        }
                    }) : deferred.reject,
                });
                parameters.push(deferred.promise);
                continue;
            } 

            const dependencyBinding = this.#baseIdToBinding.get(dependencyId.baseId())!;
            
            if (supplier) {
                const passedCache: ScopeCache = binding.scope === supplierScope ? supplierCache : requestCache;
                if (supplier.sync) {
                    parameters.push(() => {
                        const scopeCache = new Map();
                        return this.#getSync(
                            dependencyBinding, 
                            supplier.propagateScope ? passedCache : scopeCache,
                            scopeCache
                        );
                    });
                } else {
                    parameters.push(async () => {
                        const scopeCache = new Map();
                        return this.#getMaybeSync(
                            dependencyBinding, 
                            supplier.propagateScope ? passedCache : scopeCache,
                            scopeCache
                        );
                    })
                }
            } else {
                const dependency = this.#getSyncImplementation(dependencyBinding, requestCache, supplierCache, lateBindingCache);
                lateBindingRequests.push(...dependency.lateBindingRequests);
                parameters.push(dependency.value);
            }
        }
        const value = binding.provider(...parameters);

        if (value === null) {
            if (!binding.outputId.annotations.nullable) {
                throw new HaystackNullResponseError(binding.outputId);
            }
        } else if (value === undefined) {
            if (!binding.outputId.annotations.undefinable) {
                throw new HaystackUndefinedResponseError(binding.outputId);
            }
        } else if (binding.outputId.construct) {
            if (!(value instanceof binding.outputId.construct)) {
                throw new HaystackInstanceOfResponseError(binding.outputId, value);
            }   
        }

        for (const { registry } of lateBindingRequests) {
            registry.set(binding, { value });
        }
        // Promise is not actually provided, since the _async_ version of this binding should never be called,
        // because we prefer sync version.
        // **NOTE** Opposite is not necessarily true. The async version does _eventually_ populate `value` because optimistic
        // scopes can transition from async -> sync.
        relevantCache?.set(binding, Object.assign(cacheContainer, { value }));
        return {
            value,
            lateBindingRequests,
        };
    }

    #preloaded: Promise<void> | null = null;
    /**
     * Pre-calculate all optimistic singletons.
     * 
     * Conceptually it is safe to run multiple times, due to scope caching. Attempts to improve performance
     * by just returning a promise that resolves with a previous `preload`'s success.
     * 
     * All singletons are attempted to be invoked in parallel. However the invocation of singleton dependencies
     * is called prior to a single instance, as pre-calculated in `#wireSingletons`, and caching will kick in
     * for following requests.
     * 
     * If this is an all sync-container, fall back on the sync version of this method to ensure all instances are 
     * cached before the method retuns.
     * 
     * Ensures that container is wired before any loading.
     */
    async preload(): Promise<void> {

        // Similar to implementation methods, it is important that no `await` occurs until
        // `#preloaded` has been written to, to ensure no race conditions between multiple `preload` calls.
        if (this.#preloaded) {
            return this.#preloaded;
        }

        if (this.#isSync) {
            return this[preloadSyncSym]();
        }
        this.wire();

        this.#preloaded = Promise.resolve().then(async () => {
            const requestScope: ScopeCache = new Map();
            const requestSingleton = async (binding: GenericBinding): Promise<void> => {
                const dependencies = this.#singletonMap.get(binding)!;
                await Promise.all(dependencies.map(dependency => requestSingleton(dependency)));
                await this.#getMaybeSync(binding, requestScope, requestScope);
            };
            await Promise.all([...this.#singletonMap.keys()].map(binding => requestSingleton(binding)));
        }).catch(err => {
            this.#preloaded = null;
            return Promise.reject(err);
        });
        await this.#preloaded;
    }

    /**
     * Sync version of {@link preload}. 
     * 
     * Similar to `preload`, technically safe to invoke multiple times, but short-circuits on following requests
     * to improve performance.
     * 
     * Ensures that container is wired before any loading.
     */
    #preloadSync(): void {
        if (this.#preloaded) {
            return;
        }
        this.wire();

        const requestScope: ScopeCache = new Map();
        const requestSingleton = (binding: GenericBinding): void => {
            const dependencies = this.#singletonMap.get(binding)!;
            for (const dependency of dependencies) {
                requestSingleton(dependency);
            }
            this.#getSync(binding, requestScope, requestScope);
        };
        for (const binding of this.#singletonMap.keys()) {
            requestSingleton(binding);
        }

        this.#preloaded = Promise.resolve();
    }

    /**
     * Expose private field via a symbol to provide close to private functionality, 
     * while still being accessible in the same file so it can be properly exposed in the {@link SyncContainer}.
     */
    protected get [preloadSyncSym](): () => void {
        return this.#preloadSync;
    }

    /**
     * Handle the top-level request for an instance.
     * Attempts to defer to sync version if possible.
     * 
     * If it is the beginning of a request (rather than a scope-propagating supplier) instantiate all optimistic requests first.
     * 
     * Then create the actual instance, and resolve any late-binding requests that result.
     * This resolutin will kick off its own recursive requests to `#getMaybeSync`, and while the base case is not explicitly
     * stated, this is safe because of prior checks ensure the container has a healthy setup.
     * 
     * @param binding binding of identifer being requested
     * @param requestCache current request cache, shared across entire request
     * @param supplierCache current scope cache, potentially same as requestCache, 
     *                      which can be used to determine if request singletons need to be instantiated first
     * @param lateBindingCache map of any bindings that have been calculated already in the current request chain, 
     *                         to be passed to actual implementations.
     * @returns promise of instantiated value, with all late-binding values resolved
     */
    async #getMaybeSync(
        binding: GenericBinding, 
        requestCache: ScopeCache, 
        supplierCache: ScopeCache, 
        lateBindingCache?: LateCache
    ): Promise<unknown> {

        if (requestCache === supplierCache && !lateBindingCache) {
            // If the caches are the same, this is a "top level" request. Note that could be either 
            // a `container.get()` _or_ a supplier that does not propagate scope. Either one will
            // require all optimistic request instances to be create before the rest of dependency chain can begin.
            const settled = await Promise.allSettled(
                this.#requestMap.get(binding)!.map(
                    async optimisticBinding => this.#getMaybeSync(optimisticBinding, requestCache, supplierCache)
                )
            );

            HaystackMultiError.validateAllSettled(settled);
        }
        lateBindingCache ??= new Map();

        // If this instance could be implemented entire synchronously, do it.
        // Note this logic has to come _after_ the optimistic requests, because the async implementation map
        // relies on the logic that these values do already exist.
        if (!this.#isAsyncImplementationMap.get(binding)) {
            return this.#getSync(binding, requestCache, supplierCache, lateBindingCache);
        }

        // Create the requested value, which creates+validates all dependencies internally.
        // However, it may include "late-binding" values as well, which are not yet created.
        // So create those next.
        const {
            value,
            lateBindingRequests
        } = await this.#getImplementation(binding, requestCache, supplierCache, lateBindingCache);

        try {
            const settled = await Promise.allSettled(
                lateBindingRequests.map(async lateBindingRequest => {
                    const { supplier } = lateBindingRequest.dependencyId.annotations;
                    const dependencyBinding = this.#baseIdToBinding.get(lateBindingRequest.dependencyId.baseId())!;
                    if (supplier) {
                        const relevantCache = lateBindingRequest.binding.scope === supplierScope ? supplierCache : requestCache
                        if (supplier.sync) {
                            lateBindingRequest.resolve(() => {
                                const scopeCache = new Map();
                                return this.#getSync(
                                    dependencyBinding, 
                                    supplier.propagateScope ? relevantCache : scopeCache,
                                    scopeCache
                                );
                            });
                        } else {
                            lateBindingRequest.resolve(async () => {
                                const scopeCache = new Map();
                                return this.#getMaybeSync(
                                    dependencyBinding, 
                                    supplier.propagateScope ? relevantCache : scopeCache,
                                    scopeCache
                                );
                            });
                        }
                    } else {
                        // Repeat the request cycle, because this value itself may invoke it's own
                        // late binding requests which need handling.
                        const val = await this.#getMaybeSync(
                            dependencyBinding,
                            requestCache, 
                            supplierCache,
                            new Map([...lateBindingCache!, ...lateBindingRequest.registry])
                        );
                        lateBindingRequest.resolve(val);
                    }
                })
            );

            HaystackMultiError.validateAllSettled(settled);
        } catch (err) {
            // Generally speaking, the failure to invoke any late-binding value means the entire dependency chain failed.
            // e.g. A depends on late bindings of B + C.
            // B was successful, but C was not.
            // We still need to fail `B` because it may circularly reference, which has failed.
            for (const { reject } of lateBindingRequests) {
                reject(err);
            }
            throw err;
        }

        return value;
    }

    /**
     * Sync version of `#getMaybeSync`. Because late-binding values use promises, it is actually impossible to _really_
     * resolve them in the same event loop as returning this instance. However, they will be resolved on the next event loop.
     * 
     * Fundamentally this is acceptable, as late-bindings should be treated as _eventually_ resolving anyways.
     * 
     * @param requestCache current request cache
     * @param supplierCache current scope cache
     * @param lateBindingCache map of any bindings that have been calculated already in the current request chain
     * @returns instantiated value, with all late-binding requests immediately resolving on the next event loop.
     */
    #getSync(
        binding: GenericBinding, 
        requestCache: ScopeCache, 
        supplierCache: ScopeCache,
        lateBindingCache?: LateCache
    ): unknown {

        if (requestCache === supplierCache && !lateBindingCache) {
            for (const optimisticBinding of this.#requestMap.get(binding)!) {
                this.#getSync(optimisticBinding, requestCache, supplierCache);
            }
        }
        lateBindingCache ??= new Map();

        const {
            value,
            lateBindingRequests
        } = this.#getSyncImplementation(binding, requestCache, supplierCache, lateBindingCache);

        try {
            for (const lateBindingRequest of lateBindingRequests) {
                const { supplier } = lateBindingRequest.dependencyId.annotations;
                const dependencyBinding = this.#baseIdToBinding.get(lateBindingRequest.dependencyId.baseId())!;
                if (supplier) {
                    const relevantCache = lateBindingRequest.binding.scope === supplierScope ? supplierCache : requestCache;
                    if (supplier.sync) {
                        lateBindingRequest.resolve(() => {
                            const scopeCache: ScopeCache = new Map();
                            return this.#getSync(
                                dependencyBinding, 
                                supplier.propagateScope ? relevantCache : scopeCache,
                                scopeCache
                            );
                        });
                    } else {
                        lateBindingRequest.resolve(async () => {
                            const scopeCache: ScopeCache = new Map();
                            return this.#getMaybeSync(
                                dependencyBinding, 
                                supplier.propagateScope ? relevantCache : scopeCache,
                                scopeCache
                            );
                        });
                    }
                } else {
                    const val = this.#getSync(
                        dependencyBinding,
                        requestCache, 
                        supplierCache,
                        new Map([...lateBindingCache, ...lateBindingRequest.registry])
                    );
                    lateBindingRequest.resolve(val);
                }
            }
        } catch (err) {
            for (const { reject } of lateBindingRequests) {
                reject(err);
            }
            throw err;
        }

        return value;
    }

    /**
     * Expose private field via a symbol to provide close to private functionality, 
     * while still being accessible in the same file so it can be properly exposed in the {@link SyncContainer}.
     */
    protected get [getSyncSym]() {
        return this.#getSync;
    }

    /**
     * Request an instance from the container.
     * 
     * Type-checking enforces that the requested value is actually defined in this container, and translates the requested
     * identifier to instance type.
     * 
     * Will attempt to preload any optimistic singletons, if not already done.
     * 
     * @param id {@link HaystackId} to instantiate
     */
    public get<Id extends GenericHaystackId>(
        id: Id,
        ...invalidInput: [NonExtendable<StripAnnotations<HaystackIdType<Id>, 'latebinding' | 'supplier'>, Id['annotations']['named']>] extends Outputs ? [] : NoBindingDeclared
    ): Promise<StripAnnotations<HaystackIdType<Id>, 'latebinding' | 'supplier'>>;
    public get<Constructor extends IsClass>(
        clazz: Constructor,
        ...invalidInput: [NonExtendable<InstanceOfClass<Constructor>, null>] extends Outputs ? [] : NoBindingDeclared
    ): Promise<InstanceOfClass<Constructor>>;
    public async get<Id extends GenericHaystackId>(
        ...[idOrClass]: [
            Id,
            ...([NonExtendable<StripAnnotations<HaystackIdType<Id>, 'latebinding' | 'supplier'>, Id['annotations']['named']>] extends Outputs ? [] : NoBindingDeclared)
        ]
    ): Promise<StripAnnotations<HaystackIdType<Id>, 'latebinding' | 'supplier'>> {
        const id = unsafeIdentifier(idOrClass).supplier(false).lateBinding(false);
        const binding = this.idToBinding.get(id);
        if (!binding) {
            throw new HaystackProviderMissingError([id]);
        }
        await this.preload();

        const requestCache: ScopeCache = new Map();
        return this.#getMaybeSync(binding, requestCache, requestCache) as Promise<StripAnnotations<HaystackIdType<Id>, 'latebinding' | 'supplier'>>;
    }
}

export class SyncContainer<Outputs extends [Extendable]> extends AsyncContainer<Outputs> {

    public static [createContainerSym]<Outputs extends [Extendable]>(bindings: ReadonlyMap<GenericHaystackId, GenericBinding>) {
        return new SyncContainer<Outputs>(bindings);
    }

    /**
     * Sync version of {@link preload}.
     * 
     * Instantiates all optimistic singletons.
     */
    public preloadSync() {
        this[preloadSyncSym]();
    }

    /**
     * Sync version of {@link get}.
     * 
     * Type checking enforces that the requested identifier exists in the container, and translates requested id to response type.
     * 
     * Will preload all singletons if not already done.
     */
    public getSync<Id extends GenericHaystackId>(
        id: Id,
        ...invalidInput: [NonExtendable<StripAnnotations<HaystackIdType<Id>, 'latebinding' | 'supplier'>, Id['annotations']['named']>] extends Outputs ? [] : [1]
    ): StripAnnotations<HaystackIdType<Id>, 'latebinding' | 'supplier'>;
    public getSync<Constructor extends IsClass>(
        clazz: Constructor,
        ...invalidInput: [NonExtendable<InstanceOfClass<Constructor>, null>] extends Outputs ? [] : [1]
    ): InstanceOfClass<Constructor>;
    public getSync<Id extends GenericHaystackId>(
        ...[idOrClass]: [
            Id,
            ...([NonExtendable<StripAnnotations<HaystackIdType<Id>, 'latebinding' | 'supplier'>, Id['annotations']['named']>] extends Outputs ? [] : [1])
        ]
    ): StripAnnotations<HaystackIdType<Id>, 'latebinding' | 'supplier'> {
        const id = unsafeIdentifier(idOrClass).supplier(false).lateBinding(false);
        const binding = this.idToBinding.get(id);
        if (!binding) {
            throw new HaystackProviderMissingError([id]);
        }
        this[preloadSyncSym]();
        const requestCache: ScopeCache = new Map();
        return this[getSyncSym](binding, requestCache, requestCache) as StripAnnotations<HaystackIdType<Id>, 'latebinding' | 'supplier'>;
    }
}

export const createSyncContainer = SyncContainer[createContainerSym];
delete (SyncContainer as Record<typeof createContainerSym, unknown>)[createContainerSym];

export const createAsyncContainer = AsyncContainer[createContainerSym];
delete (AsyncContainer as Record<typeof createContainerSym, unknown>)[createContainerSym];