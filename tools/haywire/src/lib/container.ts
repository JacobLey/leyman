import pDefer, { type DeferredPromise } from 'p-defer';
import {
    type BindingOutputType,
    type GenericBinding,
    type InstanceBinding,
    TempBinding,
} from '#binding';
import {
    HaywireCircularDependencyError,
    HaywireDuplicateOutputError,
    HaywireInstanceOfResponseError,
    HaywireMultiError,
    HaywireNullResponseError,
    HaywireProviderMissingError,
    HaywireSyncSupplierError,
    HaywireUndefinedResponseError,
} from '#errors';
import {
    expandOutputId,
    type GenericHaywireId,
    type GenericOutputHaywireId,
    type HaywireIdType,
    type OutputHaywireId,
    type StripAnnotations,
    unsafeIdentifier,
} from '#identifier';
import {
    optimisticRequestScope,
    optimisticSingletonScope,
    requestScope,
    type Scopes,
    singletonScope,
    supplierScope,
    transientScope,
} from '#scopes';
import type { Extendable, InstanceOfClass, InvalidInput, IsClass, NonExtendable } from '#types';

/**
 * Used during late-binding instantiations, as a way to provide references to
 * "this already exists in request chain, so can re-use it".
 */
type LateCache = Map<
    GenericBinding,
    {
        value: unknown;
    }
>;
/**
 * Cached values for scope, to prevent re-instantiations.
 *
 * Async version will rely on the `promise`, which will resolve to the `value`.
 * Sync version will just rely on the `value` and populate an auto-resolving promise
 * (and we generally protect against the possibility that sync version will try to access value before populated).
 *
 * Note that the `promise` wraps the value in a tuple, in order to prevent accidentally merging with the raw value
 * in the case that it is a promise itself (not a recommended pattern, but supported nonetheless).
 */
type ScopeCache = Map<
    GenericBinding,
    {
        promise?: Promise<readonly [unknown]>;
        value?: unknown;
    }
>;
/**
 * Generated by a binding to bubble up to top-level request.
 * Extends a deferred promise that is expected to be resolved with the late-bound value, or rejected
 * with any errors that pop up in the meantime.
 *
 * The registry will be populated by instances that are created in the chain, so that _eventually_ that value
 * can be re-used when requested during late binding.
 */
interface LateBindingRequest extends DeferredPromise<unknown> {
    binding: GenericBinding;
    dependencyId: GenericHaywireId;
    registry: LateCache;
}

export type Container<Outputs extends [Extendable], Async extends boolean> = Async extends true
    ? AsyncContainer<Outputs>
    : SyncContainer<Outputs>;

export type ExpandedContainer<
    Outputs extends [Extendable],
    Bindings extends GenericBinding,
    Async extends boolean,
> = Container<BindingOutputType<Bindings['outputId']> | Outputs, Async>;

type NoBindingDeclared = [InvalidInput<'NoBindingDeclared'>];

declare const typeTracking: unique symbol;
const createContainerSym = Symbol('createContainer');
const preloadSyncSym = Symbol('preloadSync');
const getSyncSym = Symbol('getSync');
const addBoundInstancesSym = Symbol('addBoundInstances');

/**
 * Container that will be wired to generate instances on demand.
 * Supports async providers externally, and sync providers internally
 * (either via suppliers or the extended {@link SyncContainer} class).
 *
 * Type declarations on the class are based on all the possible allowed inputs
 * (e.g. if based on a binding of Foo, there are entries for both Foo + Foo | null).
 *
 * This typing should be considered an internal implementation, and not hard-coded in
 * any way.
 *
 * Instances of containers are not created directly, and should be implemented via `createContainer`
 * which will use an underlying `Module` and perform the necessary checks to ensure that all
 * necessary bindings exist.
 *
 * Using a container comes in four steps.
 * 1) Checking
 *    - Optional step, although produces potentially unsafe code.
 *    - Should only be skipped if checks are performed elsewhere (e.g. during unit tests).
 * 2) Wiring
 *    - Sets up the actual data flow to generate instances based on scopes and suppliers.
 *    - Will perform checks, if not explicitly performed already
 * 3) Preload
 *    - Instantiates any optimistic singletons
 *    - Will perform wiring, if not explicitly performed already
 * 4) Get
 *    - Main use case of container. Used for actual instantiation, and can be used to continue to create more instances.
 *    - Will perform preload, if not explicitly performed already.
 */
export class AsyncContainer<Outputs extends [Extendable]> {
    private declare [typeTracking]: Outputs;
    readonly #isSync: boolean;
    readonly #bindings: ReadonlySet<GenericBinding>;
    readonly #baseIdToBinding: ReadonlyMap<GenericOutputHaywireId, GenericBinding>;
    readonly #upstreamDependents: Map<GenericBinding, Set<GenericBinding>>;
    #checked: boolean;
    #wired: boolean;
    readonly #singletonMap: Map<GenericBinding, readonly GenericBinding[]>;
    readonly #requestMap: Map<GenericBinding, readonly GenericBinding[]>;
    readonly #isAsyncImplementationMap: Map<GenericBinding, boolean>;
    readonly #singletonCache: ScopeCache = new Map();
    #preloaded: Promise<void> | null = null;

    protected readonly idToBinding: ReadonlyMap<GenericOutputHaywireId, GenericBinding>;

    /**
     * Create a container based on a map of bindings (coming from a module)
     * or from another container to be cloned.
     *
     * If input is map of bindings, populate datasets with binding data and defer to future user interaction for
     * checking/wiring/preloading.
     *
     * If input is exiting container, shallow copy all internal datasets _except_ singleton caches.
     * So if a wired container will remain wired after clone.
     * Note that in order to properly clone a SyncContainer, the SyncContainer constructor must be called first.
     *
     * @param idToBinding - map of id->binding or container
     */
    protected constructor(
        idToBinding: AsyncContainer<Outputs> | ReadonlyMap<GenericOutputHaywireId, GenericBinding>
    ) {
        if (idToBinding instanceof AsyncContainer) {
            const container = idToBinding;
            this.idToBinding = new Map(container.idToBinding);
            this.#bindings = new Set(container.#bindings);
            this.#baseIdToBinding = new Map(container.#baseIdToBinding);
            this.#upstreamDependents = new Map(container.#upstreamDependents);

            this.#isSync = container.#isSync;
            this.#checked = container.#checked;
            this.#wired = container.#wired;

            this.#singletonMap = new Map(container.#singletonMap);
            this.#requestMap = new Map(container.#requestMap);
            this.#isAsyncImplementationMap = new Map(container.#isAsyncImplementationMap);
        } else {
            this.idToBinding = new Map(idToBinding);
            this.#bindings = new Set(idToBinding.values());
            const bindingsArr = [...this.#bindings];
            this.#baseIdToBinding = new Map(
                bindingsArr.map(binding => [binding.outputId.baseId(), binding])
            );
            this.#upstreamDependents = new Map();

            this.#isSync = bindingsArr.every(binding => !binding.isAsync);
            this.#checked = false;
            this.#wired = false;

            this.#singletonMap = new Map();
            this.#requestMap = new Map();
            this.#isAsyncImplementationMap = new Map();
        }
    }

    /**
     * Exposed to module to create container in protected type-safe way.
     *
     * @param bindings - module bindings
     * @returns type-safe async container
     */
    public static [createContainerSym]?<Outputs extends [Extendable]>(
        bindings: AsyncContainer<Outputs> | ReadonlyMap<GenericOutputHaywireId, GenericBinding>
    ): AsyncContainer<Outputs> {
        return new AsyncContainer<Outputs>(bindings);
    }

    /**
     * Attach a set of bindings to a factory-managed container.
     *
     * A container may have `TempBinding`s included, which are enough to pass checks + wires, but will fail to
     * actually instantiate the necessary instances.
     *
     * The factory will then collect these actual bindings later on, and pass them to the container.
     * The container is cloned internally first (to avoid accidental mutations of the original) then the `TempBinding`s
     * are replaced with `InstanceBindings` (guaranteed to be sync and have no other dependencies).
     *
     * Each `InstanceBinding` is internally spread over the possible outputIds, so callers should only provide a single
     * binding for each output.
     *
     * The existing wiring (_if_ already wired) is updated to point to these new bindings.
     *
     * @param container - Container (both sync or async) with temp bindings
     * @param bindings - list of instance bindings to
     * @returns cloned container with bindings attached
     * @throws {HaywireDuplicateOutputError} When incoming bindings overlap with existing declarations
     */
    public static [addBoundInstancesSym]?<
        Outputs extends [Extendable],
        Bindings extends InstanceBinding<GenericOutputHaywireId>,
        Async extends boolean,
    >(
        container: Container<Outputs, Async>,
        bindings: Bindings[]
    ): ExpandedContainer<Outputs, Bindings, Async> {
        const cloned = new (container.constructor as typeof AsyncContainer | typeof SyncContainer)(
            container
        ) as ExpandedContainer<Outputs, Bindings, Async>;

        for (const binding of bindings) {
            const existingBinding = cloned.#baseIdToBinding.get(binding.outputId.baseId());
            if (existingBinding) {
                if (existingBinding instanceof TempBinding) {
                    (cloned.#bindings as Set<GenericBinding>).delete(existingBinding);

                    if (cloned.#wired) {
                        cloned.#singletonMap.delete(existingBinding);
                        cloned.#isAsyncImplementationMap.delete(existingBinding);

                        const upstreamDependents = cloned.#upstreamDependents.get(existingBinding)!;
                        cloned.#upstreamDependents.set(binding, upstreamDependents);
                        const replaceBinding = (arr: readonly GenericBinding[]): GenericBinding[] =>
                            arr.map(bind => {
                                if (bind === existingBinding) {
                                    return binding;
                                }
                                return bind;
                            });
                        for (const dependent of upstreamDependents) {
                            cloned.#singletonMap.set(
                                dependent,
                                replaceBinding(cloned.#singletonMap.get(dependent)!)
                            );
                        }
                    }

                    cloned.#upstreamDependents.delete(existingBinding);
                } else {
                    throw new HaywireDuplicateOutputError([binding.outputId.baseId()]);
                }
            } else if (cloned.#wired) {
                cloned.#upstreamDependents.set(binding, new Set());
            }

            for (const outputId of expandOutputId(binding.outputId)) {
                // @ts-expect-error
                (cloned.idToBinding as Map<GenericOutputHaywireId, GenericBinding>).set(
                    outputId,
                    binding
                );
            }

            (cloned.#bindings as Set<GenericBinding>).add(binding);
            (cloned.#baseIdToBinding as Map<GenericOutputHaywireId, GenericBinding>).set(
                binding.outputId.baseId(),
                binding
            );
            cloned.#upstreamDependents.set(binding, new Set());

            if (container.#wired) {
                cloned.#singletonMap.set(binding, []);
                cloned.#requestMap.set(binding, []);
                cloned.#isAsyncImplementationMap.set(binding, false);
            }
        }

        return cloned;
    }

    /**
     * Pre-calculate paths for requests to take, so that the actual requests to the container can be determined immediately.
     * Does not actually perform any instantiations.
     *
     * Can safely be called multiple times, and will immediately short circuit successfully after the first.
     *
     * Calls check internally, to ensure container is in a healthy state before continuing.
     *
     * The wiring performed is:
     * Optimistic Singletons
     *   Optimistic singletons are tricky becuase despite their _potentially_ async nature, it is always safe to treat them as
     *     sync in other parts of requests. During the very beginning of initialization though, that is not necessarily safe,
     *     so calculate the dependency order in which singletons can be instantiated without causing issues.
     * Optimistic Requests
     *   Similar to singletons, optimistic requests can potentially be treated as sync. Again we need to ensure the values
     *     are constructed in the right order to safely access. Also ensures we _only_ optimistically instantiate providers
     *     relevant to this top-level request.
     * Determine which dependencies are safe for async
     *   Where possible, we want to use synchronous instantiation. The logic is overall simpler and more performant. However,
     *     it is not clear based on the binding alone whether or not an instantion can be done syncronously (e.g. has async dependencies)
     *     so this is pre-calculated.
     */
    public wire(): void {
        if (this.#wired) {
            return;
        }

        this.check();

        for (const binding of this.#bindings) {
            this.#upstreamDependents.set(binding, new Set());
        }
        this.#wireSingletons();
        this.#wireRequests();
        this.#wireAsyncs();

        this.#wired = true;
    }

    /**
     * Check internals of container to protect against edge cases that cannot be protected against via traditional type safety.
     *
     * Can safely be called multiple times, and will immediately short circuit successfully after the first.
     *
     * The checks performed are:
     * Ensuring all dependencies have a binding
     *   Ideally module logic protect against this, but it is possible to accidentially re-instantiate an identifier, or to
     *     have classes that _should_ be treated separately, but actually are exact matches in Typescript's duck typing.
     * Protect Circular dependencies
     *   Circular dependencies can be tricky to see directly, as they may be the result of large chains including suppliers.
     *     The type system does not attempt to protect against circulars for this reason, so a check must be performed to ensure
     *     either no circulars exist, or they are properly protected against with late bindings and properly scoped suppliers.
     * Enforce circular suppliers
     *   The top level container will always be async if a single provider internally is async. However the suppliers generated internally
     *     _may_ be sync, if just that dependency path is all sync. The type system is not able to track this directly, because there are
     *     cases of async dependencies that can be treated as sync, because optimistic scoping will pre-cache the value.
     */
    public check(): void {
        if (this.#checked) {
            return;
        }
        this.#checkForDependenciesOutput();
        this.#checkForCircular();
        this.#checkForAsyncSupplier();

        this.#checked = true;
    }

    /**
     * Pre-calculate all optimistic singletons.
     *
     * Conceptually it is safe to run multiple times, due to scope caching. Attempts to improve performance
     * by just returning a promise that resolves with a previous `preload`'s success.
     *
     * All singletons are attempted to be invoked in parallel. However the invocation of singleton dependencies
     * is called prior to a single instance, as pre-calculated in `#wireSingletons`, and caching will kick in
     * for following requests.
     *
     * If this is an all sync-container, fall back on the sync version of this method to ensure all instances are
     * cached before the method retuns.
     *
     * Ensures that container is wired before any loading.
     *
     * @returns promise that resolves once all the preloads are complete
     */
    public async preloadAsync(): Promise<void> {
        // Similar to implementation methods, it is important that no `await` occurs until
        // `#preloaded` has been written to, to ensure no race conditions between multiple `preload` calls.
        if (this.#preloaded) {
            return this.#preloaded;
        }

        if (this.#isSync) {
            this[preloadSyncSym]();
            return;
        }
        this.wire();

        this.#preloaded = Promise.resolve()
            .then(async () => {
                const reqScope: ScopeCache = new Map();
                const requestSingleton = async (binding: GenericBinding): Promise<void> => {
                    const dependencies = this.#singletonMap.get(binding)!;
                    await Promise.all(
                        dependencies.map(async dependency => requestSingleton(dependency))
                    );
                    await this.#getMaybeSync(binding, reqScope, reqScope);
                };
                await Promise.all(
                    [...this.#singletonMap.keys()].map(async binding => requestSingleton(binding))
                );
            })
            .catch(async (err: unknown) => {
                this.#preloaded = null;
                throw err;
            });

        return this.#preloaded;
    }

    /**
     * Request an instance from the container.
     *
     * Type-checking enforces that the requested value is actually defined in this container, and translates the requested
     * identifier to instance type.
     *
     * Will attempt to preload any optimistic singletons, if not already done.
     *
     * @param id - {@link HaywireId} to instantiate
     */
    public getAsync<Id extends GenericHaywireId>(
        id: Id,
        ...invalidInput: [] &
            ([
                NonExtendable<
                    StripAnnotations<HaywireIdType<Id>, 'latebinding' | 'supplier'>,
                    Id['construct'],
                    Id['annotations']['named']
                >,
            ] extends Outputs
                ? []
                : NoBindingDeclared)
    ): Promise<StripAnnotations<HaywireIdType<Id>, 'latebinding' | 'supplier'>>;
    public getAsync<Constructor extends IsClass>(
        clazz: Constructor,
        ...invalidInput: [] &
            ([NonExtendable<InstanceOfClass<Constructor>, Constructor, null>] extends Outputs
                ? []
                : NoBindingDeclared)
    ): Promise<InstanceOfClass<Constructor>>;
    public async getAsync<Id extends GenericHaywireId>(
        idOrClass: Id
    ): Promise<StripAnnotations<HaywireIdType<Id>, 'latebinding' | 'supplier'>> {
        const id = unsafeIdentifier(idOrClass).supplier(false).lateBinding(false);
        const binding = this.idToBinding.get(id);
        if (!binding) {
            throw new HaywireProviderMissingError([id]);
        }
        await this.preloadAsync();

        const requestCache: ScopeCache = new Map();
        return this.#getMaybeSync(binding, requestCache, requestCache) as Promise<
            StripAnnotations<HaywireIdType<Id>, 'latebinding' | 'supplier'>
        >;
    }

    /**
     * Check that every dependency declared in bindings has an equivalent binding declared.
     *
     * For the most part, we are protected against this by strongly-typed modules and container creation, but there are ways to
     * accidentally get around this.
     *
     * The two main ways that type safety may fail (so this check still neeeds to exist):
     * Accidentally redefining the same identifier.
     *   The issue arises from `identifier() !== identifier()`.
     *     So even if the exact same types/names are provided, the actual values seen by javascript are different.
     *   note classes are generally protected from this (`identifier(Foo) === identifier(Foo)`) but can still result in other errors (see second point).
     * Using class constructors for instances that are exact matches via duck-typing.
     *   According to typescript, classes that have the exact same interface are replaceable with eachother.
     *     Often times this is actually desired behavior, but can result in unexpected behavior.
     *     ```
     *     class Foo {
     *         similarValue: 123;
     *     }
     *     class Bar {
     *         similarValue: 123;
     *     }
     *     // Legal!
     *     const x: Foo = new Bar();
     *     ```
     *     As a result, haywire cannot tell the difference between `identifier(Foo)` and `identifier(Bar)`.
     *
     * @throws when a binding declares a dependency that is not found within the container
     */
    #checkForDependenciesOutput(): void {
        const uniqueDependencyIds = // DepdupeEffectiveBaseId(
            new Set(
                [...this.#bindings].flatMap(binding =>
                    binding.dependencyIds.map(id => id.lateBinding(false).supplier(false))
                )
            );

        const noProviderFoundIds: GenericOutputHaywireId[] = [];

        for (const dependencyId of uniqueDependencyIds) {
            if (!this.idToBinding.has(dependencyId)) {
                noProviderFoundIds.push(dependencyId);
            }
        }

        if (noProviderFoundIds.length > 0) {
            throw new HaywireProviderMissingError(noProviderFoundIds);
        }
    }

    /**
     * Flag any instances of "illegal" circular dependencies, and throw an error.
     *
     * Circular bindings are defined as cases where in order to create dependency `A`,
     * Haywire must first provide it with an instance of `A` (either directly, or via the chain of sub-dependencies)
     *
     * This is naively impossible, and results in infinite requests for `A`, even if using a scope that
     * can take advantage of caching (because the original request can never return to populate the cache).
     *
     * The best solution is to simply avoid circular dependencies in design.
     *
     * The next best is to utilize "late-binding". This means the dependency is on a promise that _eventually_ resolves to
     * the requested value.
     *
     * For non-supplier dependencies, late-binding successfully "breaks the chain".
     *
     * e.g. `A` depends on `B` depends on `C` depends on `D`, which _circularly_ depends on `A`.
     * Making any single of these dependencies late-binding is enough.
     *
     * For supplier dependencies, this may not be enough.
     *
     * e.g. `A` depends on `B`. `B` depends on late-binding `C`. `C` depends on a supplier of `D`. `D` depends on `A`.
     *
     * In order to supply the instance of `C` to `B`, we need to create a supplier of `D`. This _supplier_ can _theoretically_ be used
     * immediately in the provider, which instantiates a _new_ request for `D` (which requests `A`, and `B`!).
     *
     * This is the infinite loop we were trying to avoid.
     *
     * Suppliers are only allowed in a circular dependency when a binding in the chain has a scope that can re-use a previously cached value.
     * That means either a singleton scope, or request scope with propagation.
     *
     * In the example above, if the supplier propagated scope and `B` had been `request scope`d, it would be valid.
     * This is because newly "supplied" instaces of D could fall back on cached version of B instead of re-instanting and infinitely looping.
     *
     * In order to detect these circular dependencies, perform a check for each individual binding.
     * Iterate over each dependency, tracking the current "chain".
     *
     * If we end at a binding with no dependencies, that "chain" is safe.
     * If we end up at a dependency that is _already_ in the chain, end this check (if it is illegally circular, let that binding perform its own check).
     * If we end up at a dependency of our original binding:
     *     If we never crossed a late-binding boundary, flag this as circular
     *     Else
     *          If there is a singleton-scoped in the chain, it is safe
     *          If there is a request-scoped in the chain
     *              If never crossed a non-propagating supplier boundary, it is safe
     *              else flag this is as circular
     *
     * We can optimize the _safe_ paths a bit.
     * If we know `A` is not flagged as a circular, then any time `A` comes up in the check, we can immediately declare the chain safe.
     * However we cannot do the same for _unsafe_ paths (which matters less, since performance in the case that eventually throws and error is less important).
     *
     * example: `A` depends on `B`, `B` depends on `C`, and `C` depends on `B`.
     * Both `B` and `C` are unsafe circulars. However this is not `A`'s fault, and should be excluded from the reporting.
     *
     * @throws when dependencies found to be circularly dependenct on themselves. The chains povided are unique.
     */
    #checkForCircular(): void {
        const safeBindings = new Set<GenericBinding>();
        const circularPaths: GenericHaywireId[][] = [];
        const singletonScopes = new Set([optimisticSingletonScope, singletonScope]);
        const requestScopes = new Set([optimisticRequestScope, requestScope]);

        const isChainSafe = (chain: GenericHaywireId[]): boolean => {
            if (chain.some(dependencyId => dependencyId.annotations.lateBinding)) {
                // Only if there is late binding can circular dependencies be acceptable
                const bindingChain = chain.map((dependencyId, i) => ({
                    // We want the _next_ dependency in the chain, that is declared by
                    // _this_ dependency's binding
                    dependencyId: chain[(i + 1) % chain.length]!,
                    binding: this.#baseIdToBinding.get(dependencyId.baseId())!,
                }));

                if (bindingChain.some(({ binding }) => singletonScopes.has(binding.scope))) {
                    // Singletons will eventually run into cached value, so are safe (regardless of suppliers)
                    return true;
                }

                if (bindingChain.some(({ binding }) => requestScopes.has(binding.scope))) {
                    // Request scopes are safe _only_ if the scope is propagated the entire way.
                    return bindingChain.every(({ binding, dependencyId }) => {
                        const { supplier } = dependencyId.annotations;
                        if (typeof supplier === 'object') {
                            return supplier.propagateScope && binding.scope !== supplierScope;
                        }
                        return true;
                    });
                }

                // If there are no suppliers, this is safe
                return bindingChain.every(
                    ({ dependencyId }) => dependencyId.annotations.supplier === false
                );
            }
            return false;
        };

        const isBindingSafe = (
            outputId: GenericHaywireId,
            dependencyChain: Set<GenericHaywireId>
        ): boolean => {
            const binding = this.#baseIdToBinding.get(outputId.baseId())!;

            if (safeBindings.has(binding)) {
                return true;
            }

            if (dependencyChain.has(outputId)) {
                let foundCircular = false;
                const circularChain = [...dependencyChain].filter(id => {
                    if (id === outputId) {
                        foundCircular = true;
                    }
                    return foundCircular;
                });
                if (isChainSafe(circularChain)) {
                    return true;
                }
                circularPaths.push(circularChain);
                return false;
            }
            dependencyChain.add(outputId);

            let isSafe = true;
            for (const dependencyId of binding.dependencyIds) {
                isSafe = isBindingSafe(dependencyId, new Set(dependencyChain)) && isSafe;
            }
            return isSafe;
        };

        for (const binding of this.#bindings) {
            if (isBindingSafe(binding.outputId, new Set())) {
                safeBindings.add(binding);
            }
        }

        if (circularPaths.length > 0) {
            throw new HaywireCircularDependencyError(circularPaths);
        }
    }

    /**
     * Suppliers are by default synchronous, even if the underlying container is async
     * (although they can be flagged async to avoid this issue altogether).
     *
     * A supplier can be sync when the binding is synchronous and every dependency qualifies as synchronous.
     * It can also be synchronous if async binding or dependencies can utilize optimistic scopes.
     *
     * Note that late-binding does not "protect" a binding from async dependencies.
     * This is because late-bindings will resolve by the time the request completes
     * (or rather, immediately on the next event loop, which is the best we can do with promises).
     * So a late-binding dependency must resolve syncronously as well.
     *
     * Suppliers that propagate their scope (and are not supplier-scoped themselves) can benefit from optimistic request bindings,
     * but ones that do not can only rely on optimistic singletons.
     *
     * We only need to inspect sync suppliers
     * (async suppliers don't have this problem, and regular bindings can obfuscate the instantation logic, the whole point of DI)
     * to see if the dependency chain is safe.
     *
     * Some optimizations can be performed to prevent duplicate checks against suppliers.
     * e.g. both Foo + Bar has dependency on supplier of Baz can re-use the same calculation.
     *
     * @throws When a synchronous supplier is declared for a provider that must be async
     */
    #checkForAsyncSupplier(): void {
        const isSafeForSyncSupplier = (
            binding: GenericBinding,
            chain: Set<GenericOutputHaywireId>,
            optimisticScopes: Set<Scopes>
        ): boolean => {
            const baseId = binding.outputId.baseId();
            if (chain.has(baseId)) {
                // Part of circular dependency.
                // If we are sync up until this point, it can remain sync.
                return true;
            }
            if (optimisticScopes.has(binding.scope)) {
                // If the "parent" scopes have already optimistically created these resources,
                // will be synchronously available
                return true;
            }
            if (binding.isAsync) {
                // Value cannot guaranteed to be present, even if belonging to "parent" scope.
                return false;
            }
            return binding.dependencyIds.every(dependencyId => {
                const { supplier } = dependencyId.annotations;
                if (typeof supplier === 'object' && (!supplier.propagateScope || !supplier.sync)) {
                    // Either async boundary or separate request.
                    // Separate requests are validated in separate iteration
                    return true;
                }
                // Continue checking dependencies
                return isSafeForSyncSupplier(
                    this.#baseIdToBinding.get(dependencyId.baseId())!,
                    new Set([...chain, baseId]),
                    optimisticScopes
                );
            });
        };

        const syncSuppliers = [...this.#bindings]
            .flatMap(binding => binding.dependencyIds.map(id => [binding, id] as const))
            .filter(([, dependencyId]) => {
                const { supplier } = dependencyId.annotations;
                return typeof supplier === 'object' && supplier.sync;
            });

        const safeBindings = new Set<GenericBinding>();
        const unsafeBindings = new Set<GenericBinding>();
        const unsafeSupplierBindings: {
            bindingOutputId: GenericOutputHaywireId;
            supplierId: GenericHaywireId;
        }[] = [];
        const addUnsafePair = (
            dependencyBinding: GenericBinding,
            propagateScope: boolean
        ): void => {
            const dependencyBaseId = dependencyBinding.outputId.baseId();
            for (const binding of this.#bindings) {
                for (const depId of binding.dependencyIds) {
                    if (depId.baseId() === dependencyBaseId) {
                        const { supplier } = depId.annotations;
                        if (
                            typeof supplier === 'object' &&
                            supplier.sync &&
                            supplier.propagateScope === propagateScope
                        ) {
                            unsafeSupplierBindings.push({
                                bindingOutputId: dependencyBinding.outputId,
                                supplierId: depId,
                            });
                        }
                    }
                }
            }
        };

        for (const [propagateScope, isSupplierScope, optimisticScopes] of [
            // Suppliers that are the "entrypoint" for a request cannot rely on optimistic requests
            // to pre-cache async dependencies.
            [false, false, new Set([optimisticSingletonScope] as const)],
            [false, true, new Set([optimisticSingletonScope] as const)],
            // Suppliers that are _not_ the "entrypoint", but are not inheriting the original request scope cannot rely
            // on optimistic requests to pre-cache async dependencies.
            [true, true, new Set([optimisticSingletonScope] as const)],
            // Suppliers that are the propagating scope from a parent request _can_ rely on optimistic requests
            // to pre-cache async dependencies.
            [true, false, new Set([optimisticRequestScope, optimisticSingletonScope] as const)],
        ] as const) {
            const syncBindings = new Set(
                syncSuppliers
                    .filter(
                        ([, id]) =>
                            (
                                id.annotations.supplier as {
                                    propagateScope: boolean;
                                }
                            ).propagateScope === propagateScope
                    )
                    .filter(([binding]) => (binding.scope === supplierScope) === isSupplierScope)
                    .map(([, id]) => this.#baseIdToBinding.get(id.baseId())!)
                    .filter(binding => !safeBindings.has(binding) && !unsafeBindings.has(binding))
            );

            for (const syncBinding of syncBindings) {
                if (isSafeForSyncSupplier(syncBinding, new Set(), optimisticScopes)) {
                    safeBindings.add(syncBinding);
                } else {
                    unsafeBindings.add(syncBinding);
                    addUnsafePair(syncBinding, propagateScope);
                }
            }
        }

        if (unsafeSupplierBindings.length > 0) {
            throw new HaywireSyncSupplierError(unsafeSupplierBindings);
        }
    }

    /**
     * Precalcuate list of optimistic singletons that need to be instantiated, before
     * the specified optimistic singleton can be instantiated.
     *
     * Only populates entries for optimistic singletons, so possible resulting map is actually empty or
     * has no dependencies declared.
     *
     * Does not actually perform the instantations.
     */
    #wireSingletons(): void {
        const collectBindings = (
            binding: GenericBinding,
            stack: Set<GenericOutputHaywireId>
        ): GenericBinding[] => {
            if (stack.has(binding.outputId.baseId())) {
                return [];
            }

            const collected: GenericBinding[] = [];
            for (const dependencyId of binding.dependencyIds) {
                const { lateBinding, supplier } = dependencyId.annotations;
                if (lateBinding || (typeof supplier === 'object' && !supplier.sync)) {
                    continue;
                }
                const dependencyBinding = this.#baseIdToBinding.get(dependencyId.baseId())!;
                if (dependencyBinding.scope === optimisticSingletonScope) {
                    collected.push(dependencyBinding);
                } else {
                    collected.push(
                        ...collectBindings(
                            dependencyBinding,
                            new Set([...stack, dependencyId.baseId()])
                        )
                    );
                }
            }
            return collected;
        };

        for (const binding of [...this.#bindings].filter(
            bind => bind.scope === optimisticSingletonScope
        )) {
            const singletonBindings = [...new Set(collectBindings(binding, new Set()))];
            this.#singletonMap.set(binding, singletonBindings);
            for (const singletonBinding of singletonBindings) {
                this.#upstreamDependents.get(singletonBinding)!.add(binding);
            }
        }
    }

    /**
     * Map of binding being requested, to bindings that need to be optimisitcally instantiated first.
     *
     * Applies to both top-level requests, and suppliers that do not propagate scope.
     * (Suppliers that do propagate scope don't need to re-instantiate anything)
     *
     * Will contain entries for every request. This ensures that no extra values are instantiated during
     * a request that are not related to the dependency graph.
     *
     * Does not actually perform the instantiations.
     */
    #wireRequests(): void {
        const collectBindings = (
            binding: GenericBinding,
            stack: Set<GenericOutputHaywireId>
        ): GenericBinding[] => {
            if (stack.has(binding.outputId.baseId())) {
                return [];
            }

            const collected: GenericBinding[] = [];
            for (const dependencyId of binding.dependencyIds) {
                const dependencyBinding = this.#baseIdToBinding.get(dependencyId.baseId())!;
                if (dependencyBinding.scope === optimisticSingletonScope) {
                    continue;
                } else if (dependencyBinding.scope === optimisticRequestScope) {
                    collected.push(dependencyBinding);
                } else {
                    collected.push(
                        ...collectBindings(
                            dependencyBinding,
                            new Set([...stack, dependencyId.baseId()])
                        )
                    );
                }
            }
            return collected;
        };
        for (const binding of this.#bindings) {
            this.#requestMap.set(binding, [...collectBindings(binding, new Set())]);
        }
    }

    /**
     * Calculate whether any binding can be performed syncronously.
     *
     * This mapping is only checked during the async path, as we _prefer_ the sync path for simplicity and performance.
     * The sync path cannot possibly redirect the the async path, so there are checks the protect against that need.
     *
     * Note that whether or not the binding is being referenced via a top-level request, a provider dependency,
     * a late binding request, or a supplier is irrelevant to the logic here.
     *
     * The main difference between enabling sync for suppliers has to do with ability to use request caching,
     * but for the actual provider instantiation the request singletons will already exist regardless of context.
     */
    #wireAsyncs(): void {
        const optimisticScopes = new Set([optimisticRequestScope, optimisticSingletonScope]);
        const isAsync = (binding: GenericBinding, chain = new Set<GenericBinding>()): boolean => {
            if (chain.has(binding)) {
                // Come full circle. If nothing in the chain has forced async yet, we can stay sync
                return false;
            }
            const existing = this.#isAsyncImplementationMap.get(binding);
            if (typeof existing === 'boolean') {
                // Try to re-use solved portions when available
                return existing;
            }
            if (binding.isAsync) {
                // This is the only that that actually forces async implementations,
                // but can force all consumers, including seemingly sync proiders depending on late-bindings
                this.#isAsyncImplementationMap.set(binding, true);
                return true;
            }
            return binding.dependencyIds.some(dependencyId => {
                if (typeof dependencyId.annotations.supplier === 'object') {
                    // Suppliers are resolved "immediately" so that is sync
                    return false;
                }
                const dependencyBinding = this.#baseIdToBinding.get(dependencyId.baseId())!;
                if (optimisticScopes.has(dependencyBinding.scope)) {
                    // Optimistic values are pre-computed, so the actual request can always rely on cache
                    return false;
                }
                // Check dependency, appending to chain
                return isAsync(dependencyBinding, new Set([...chain, binding]));
            });
        };

        for (const binding of this.#bindings) {
            this.#isAsyncImplementationMap.set(binding, isAsync(binding));
        }
    }

    /**
     * Asynchronously instantiate a binding. Will create all dependencies first before invoking provider.
     * Supplier will be implemented as as a new internal request for that binding, potentially propagating request scope.
     * Late bindings will be implemented as a deferred promise that will be handled by the top-level request
     * (which will iteratively instantiate each dependency and resolve/reject as necessary).
     *
     * @param binding - binding being requested
     * @param requestCache - current request cache, shared across entire request
     * @param supplierCache - current scope cache, potentially same as requestCache,
     * but should be treated differently based on supplier context and scope
     * @param lateBindingCache - map of any bindings that have been calculated already in the current request chain,
     * which should be re-used if possible.
     * @returns promise of both the instantiated value, and any late binding requests that have been generated by dependencies
     * (and dependencies of dependencies)
     */
    async #getImplementation(
        binding: GenericBinding,
        requestCache: ScopeCache,
        supplierCache: ScopeCache,
        lateBindingCache: LateCache
    ): Promise<{
        value: unknown;
        lateBindingRequests: LateBindingRequest[];
    }> {
        // If already created instance in same dependency chain, just re-use that one!
        const lateBindingValue = lateBindingCache.get(binding);
        if (lateBindingValue) {
            return {
                value: lateBindingValue.value,
                lateBindingRequests: [],
            };
        }

        const relevantCache = {
            [transientScope]: null,
            [optimisticSingletonScope]: this.#singletonCache,
            [singletonScope]: this.#singletonCache,
            [optimisticRequestScope]: requestCache,
            [requestScope]: requestCache,
            [supplierScope]: supplierCache,
        }[binding.scope];

        // If an instance already exists (or is being created in parallel) in the same request, return that immediately.
        // **NOTE** It is very important that any code that exists between here and the "write to cache" later down
        // is _synchronous_ to prevent any possible race condition between requests and their scoping.
        // Promises generated in the middle will be collected and awaited afterwards.
        if (relevantCache) {
            const cached = relevantCache.get(binding);
            if (cached) {
                const [value] = await cached.promise!;
                return {
                    value,
                    lateBindingRequests: [],
                };
            }
        }

        // Create the value that will be put in cache immediately. Will be necessary to check during late binding rejections
        // to safely evict from cache.
        const cacheContainer = {};

        const lateBindingRequests: LateBindingRequest[] = [];

        // Setup a collection of promises that will be extended by every late binding.
        // Will be used later during the caching to ensure the cache can't resolve until the late-bindings resolve.
        const lateBindingPromises: Promise<unknown>[] = [];

        // Collect a promise that will resolve with the (wrapped) value, but don't actually
        // await it until we get the cache setup.
        const outputPromise = (async () => {
            const settled = await Promise.allSettled(
                binding.dependencyIds.map(async (dependencyId): Promise<readonly [unknown]> => {
                    const { lateBinding, supplier } = dependencyId.annotations;
                    if (lateBinding) {
                        const deferred = pDefer();
                        lateBindingPromises.push(deferred.promise);
                        const registry: LateCache = new Map();
                        lateBindingRequests.push({
                            ...deferred,
                            binding,
                            dependencyId,
                            registry,
                        });
                        return [deferred.promise];
                    }

                    const dependencyBinding = this.#baseIdToBinding.get(dependencyId.baseId())!;

                    if (typeof supplier === 'object') {
                        // If we propagate scope, we need to ensure we are propagating the "selected" scope for this binding
                        const passedCache: ScopeCache =
                            binding.scope === supplierScope ? supplierCache : requestCache;
                        if (supplier.sync) {
                            return [
                                () => {
                                    const scopeCache: ScopeCache = new Map();
                                    return this.#getSync(
                                        dependencyBinding,
                                        supplier.propagateScope ? passedCache : scopeCache,
                                        scopeCache
                                    );
                                },
                            ];
                        }
                        return [
                            async () => {
                                const scopeCache: ScopeCache = new Map();
                                return this.#getMaybeSync(
                                    dependencyBinding,
                                    supplier.propagateScope ? passedCache : scopeCache,
                                    scopeCache
                                );
                            },
                        ];
                    }
                    // Attempt to generate dependencies syncronously _if possible_ for both performance optimizations,
                    // and to help prevent race conditions.
                    const dependency = this.#isAsyncImplementationMap.get(dependencyBinding)!
                        ? await this.#getImplementation(
                              dependencyBinding,
                              requestCache,
                              supplierCache,
                              lateBindingCache
                          )
                        : this.#getSyncImplementation(
                              dependencyBinding,
                              requestCache,
                              supplierCache,
                              lateBindingCache
                          );
                    lateBindingRequests.push(...dependency.lateBindingRequests);
                    return [dependency.value];
                })
            );

            HaywireMultiError.validateAllSettled(settled);

            const dependencies = settled.flatMap(settle => settle.value);
            const value = binding.isAsync
                ? await binding.provider(...dependencies)
                : binding.provider(...dependencies);

            if (value === null) {
                if (!binding.outputId.annotations.nullable) {
                    throw new HaywireNullResponseError(binding.outputId);
                }
            } else if (value === undefined) {
                if (!binding.outputId.annotations.undefinable) {
                    throw new HaywireUndefinedResponseError(binding.outputId);
                }
            } else if (
                binding.outputId.construct &&
                !(value instanceof binding.outputId.construct)
            ) {
                throw new HaywireInstanceOfResponseError(binding.outputId, value);
            }

            for (const { registry } of lateBindingRequests) {
                registry.set(binding, { value });
            }
            return [value];
        })();

        // After cache has been written to, we can await any promises that have been initialized.
        if (relevantCache) {
            // Note the cache value does not _immediately_ have `value` attached to it.
            // While risky, this is safe because it will only be accessed by the sync equivalent
            // if this async method was actually generated "optimistically" and therefore fully resolved.
            const cacheValue = Object.assign(cacheContainer, {
                promise: outputPromise
                    .then(async ([value]) => {
                        cacheValue.value = value;
                        await Promise.all(lateBindingPromises);
                        return [value] as const;
                    })
                    .catch((err: unknown) => {
                        // Failures may occur because of late-bindings,
                        // or because the actual generation promise rejects
                        // (which we still have not actually awaited and checked!)
                        // so if that does happen, we need to evict this value from cache.
                        if (relevantCache.get(binding) === cacheContainer) {
                            relevantCache.delete(binding);
                        }
                        throw err;
                    }),
            }) as {
                promise: Promise<[unknown]>;
                value: unknown;
            };

            relevantCache.set(binding, cacheValue);
        }

        const [value] = await outputPromise;

        return {
            value,
            lateBindingRequests,
        };
    }

    /**
     * Synchronous version of `#getImplementation`. For the most part, logic is the same (just without promises)
     * and can defer to documentation in that method for detail.
     *
     * In general this method is preferred due to simplicitly (no promise race conditions) and to ensure sync support
     * for suppliers.
     *
     * @param binding - binding being requested
     * @param requestCache - current request cache
     * @param supplierCache - current scope cache
     * @param lateBindingCache - map of any bindings that have been calculated already in the current request chain
     * @returns both the instantiated value, and any late binding requests that have been generated by dependencies
     * @throws if the provided value is not of the correct type (e.g. null but output is not nullable)
     */
    #getSyncImplementation(
        binding: GenericBinding,
        requestCache: ScopeCache,
        supplierCache: ScopeCache,
        lateBindingCache: LateCache
    ): {
        value: unknown;
        lateBindingRequests: LateBindingRequest[];
    } {
        const lateBindingValue = lateBindingCache.get(binding);
        if (lateBindingValue) {
            return {
                value: lateBindingValue.value,
                lateBindingRequests: [],
            };
        }

        const relevantCache = {
            [transientScope]: null,
            [optimisticSingletonScope]: this.#singletonCache,
            [singletonScope]: this.#singletonCache,
            [optimisticRequestScope]: requestCache,
            [requestScope]: requestCache,
            [supplierScope]: supplierCache,
        }[binding.scope];

        if (relevantCache) {
            const cached = relevantCache.get(binding);
            if (cached) {
                return {
                    value: cached.value,
                    lateBindingRequests: [],
                };
            }
        }

        const cacheContainer = {};

        const parameters: unknown[] = [];
        const lateBindingRequests: LateBindingRequest[] = [];

        for (const dependencyId of binding.dependencyIds) {
            const { lateBinding, supplier } = dependencyId.annotations;
            if (lateBinding) {
                const deferred = pDefer();
                const registry: LateCache = new Map();
                lateBindingRequests.push({
                    ...deferred,
                    binding,
                    dependencyId,
                    registry,
                    // If late bindings fail, need to evict value from cache
                    // as it is not actually fully and safely instantiated.
                    // Note that async version skips this logic, because the cached promise
                    // performs a similar check to wait for late-binding success.
                    reject: relevantCache
                        ? err => {
                              deferred.reject(err);
                              if (relevantCache.get(binding) === cacheContainer) {
                                  relevantCache.delete(binding);
                              }
                          }
                        : deferred.reject,
                });
                parameters.push(deferred.promise);
                continue;
            }

            const dependencyBinding = this.#baseIdToBinding.get(dependencyId.baseId())!;

            if (typeof supplier === 'object') {
                const passedCache: ScopeCache =
                    binding.scope === supplierScope ? supplierCache : requestCache;
                if (supplier.sync) {
                    parameters.push(() => {
                        const scopeCache: ScopeCache = new Map();
                        return this.#getSync(
                            dependencyBinding,
                            supplier.propagateScope ? passedCache : scopeCache,
                            scopeCache
                        );
                    });
                } else {
                    parameters.push(async () => {
                        const scopeCache: ScopeCache = new Map();
                        return this.#getMaybeSync(
                            dependencyBinding,
                            supplier.propagateScope ? passedCache : scopeCache,
                            scopeCache
                        );
                    });
                }
            } else {
                const dependency = this.#getSyncImplementation(
                    dependencyBinding,
                    requestCache,
                    supplierCache,
                    lateBindingCache
                );
                lateBindingRequests.push(...dependency.lateBindingRequests);
                parameters.push(dependency.value);
            }
        }
        const value = binding.provider(...parameters);

        if (value === null) {
            if (!binding.outputId.annotations.nullable) {
                throw new HaywireNullResponseError(binding.outputId);
            }
        } else if (value === undefined) {
            if (!binding.outputId.annotations.undefinable) {
                throw new HaywireUndefinedResponseError(binding.outputId);
            }
        } else if (binding.outputId.construct && !(value instanceof binding.outputId.construct)) {
            throw new HaywireInstanceOfResponseError(binding.outputId, value);
        }

        for (const { registry } of lateBindingRequests) {
            registry.set(binding, { value });
        }
        // Promise is not actually provided, since the _async_ version of this binding should never be called,
        // because we prefer sync version.
        // **NOTE** Opposite is not necessarily true. The async version does _eventually_ populate `value` because optimistic
        // scopes can transition from async -> sync.
        relevantCache?.set(binding, Object.assign(cacheContainer, { value }));
        return {
            value,
            lateBindingRequests,
        };
    }

    /**
     * Sync version of {@link preload}.
     *
     * Similar to `preload`, technically safe to invoke multiple times, but short-circuits on following requests
     * to improve performance.
     *
     * Ensures that container is wired before any loading.
     */
    #preload(): void {
        if (this.#preloaded) {
            return;
        }
        this.wire();

        const reqScope: ScopeCache = new Map();
        const requestSingleton = (binding: GenericBinding): void => {
            const dependencies = this.#singletonMap.get(binding)!;
            for (const dependency of dependencies) {
                requestSingleton(dependency);
            }
            this.#getSync(binding, reqScope, reqScope);
        };
        for (const binding of this.#singletonMap.keys()) {
            requestSingleton(binding);
        }

        this.#preloaded = Promise.resolve();
    }

    /**
     * Expose private field via a symbol to provide close to private functionality,
     * while still being accessible in the same file so it can be properly exposed in the {@link SyncContainer}.
     *
     * @returns normally private preload reference.
     */
    protected get [preloadSyncSym](): () => void {
        return this.#preload.bind(this);
    }

    /**
     * Handle the top-level request for an instance.
     * Attempts to defer to sync version if possible.
     *
     * If it is the beginning of a request (rather than a scope-propagating supplier) instantiate all optimistic requests first.
     *
     * Then create the actual instance, and resolve any late-binding requests that result.
     * This resolutin will kick off its own recursive requests to `#getMaybeSync`, and while the base case is not explicitly
     * stated, this is safe because of prior checks ensure the container has a healthy setup.
     *
     * @param binding - binding of identifer being requested
     * @param requestCache - current request cache, shared across entire request
     * @param supplierCache - current scope cache, potentially same as requestCache,
     * which can be used to determine if request singletons need to be instantiated first
     * @param lateBindingCache - map of any bindings that have been calculated already in the current request chain,
     * to be passed to actual implementations.
     * @returns promise of instantiated value, with all late-binding values resolved
     */
    async #getMaybeSync(
        binding: GenericBinding,
        requestCache: ScopeCache,
        supplierCache: ScopeCache,
        lateBindingCache?: LateCache
    ): Promise<unknown> {
        if (requestCache === supplierCache && !lateBindingCache) {
            // If the caches are the same, this is a "top level" request. Note that could be either
            // a `container.get()` _or_ a supplier that does not propagate scope. Either one will
            // require all optimistic request instances to be create before the rest of dependency chain can begin.
            const settled = await Promise.allSettled(
                this.#requestMap
                    .get(binding)!
                    .map(async optimisticBinding =>
                        this.#getMaybeSync(optimisticBinding, requestCache, supplierCache)
                    )
            );

            HaywireMultiError.validateAllSettled(settled);
        }
        const lateBindCache = lateBindingCache ?? new Map<GenericBinding, { value: unknown }>();

        // If this instance could be implemented entire synchronously, do it.
        // Note this logic has to come _after_ the optimistic requests, because the async implementation map
        // relies on the logic that these values do already exist.
        if (!this.#isAsyncImplementationMap.get(binding)) {
            return this.#getSync(binding, requestCache, supplierCache, lateBindCache);
        }

        // Create the requested value, which creates+validates all dependencies internally.
        // However, it may include "late-binding" values as well, which are not yet created.
        // So create those next.
        const { value, lateBindingRequests } = await this.#getImplementation(
            binding,
            requestCache,
            supplierCache,
            lateBindCache
        );

        try {
            const settled = await Promise.allSettled(
                lateBindingRequests.map(async lateBindingRequest => {
                    const { supplier } = lateBindingRequest.dependencyId.annotations;
                    const dependencyBinding = this.#baseIdToBinding.get(
                        lateBindingRequest.dependencyId.baseId()
                    )!;
                    if (typeof supplier === 'object') {
                        const relevantCache =
                            lateBindingRequest.binding.scope === supplierScope
                                ? supplierCache
                                : requestCache;
                        if (supplier.sync) {
                            lateBindingRequest.resolve(() => {
                                const scopeCache: ScopeCache = new Map();
                                return this.#getSync(
                                    dependencyBinding,
                                    supplier.propagateScope ? relevantCache : scopeCache,
                                    scopeCache
                                );
                            });
                        } else {
                            lateBindingRequest.resolve(async () => {
                                const scopeCache: ScopeCache = new Map();
                                return this.#getMaybeSync(
                                    dependencyBinding,
                                    supplier.propagateScope ? relevantCache : scopeCache,
                                    scopeCache
                                );
                            });
                        }
                    } else {
                        // Repeat the request cycle, because this value itself may invoke it's own
                        // late binding requests which need handling.
                        const val = await this.#getMaybeSync(
                            dependencyBinding,
                            requestCache,
                            supplierCache,
                            new Map([...lateBindCache, ...lateBindingRequest.registry])
                        );
                        lateBindingRequest.resolve(val);
                    }
                })
            );

            HaywireMultiError.validateAllSettled(settled);
        } catch (err) {
            // Generally speaking, the failure to invoke any late-binding value means the entire dependency chain failed.
            // e.g. A depends on late bindings of B + C.
            // B was successful, but C was not.
            // We still need to fail `B` because it may circularly reference, which has failed.
            for (const { reject } of lateBindingRequests) {
                reject(err);
            }
            throw err;
        }

        return value;
    }

    /**
     * Sync version of `#getMaybeSync`. Because late-binding values use promises, it is actually impossible to _really_
     * resolve them in the same event loop as returning this instance. However, they will be resolved on the next event loop.
     *
     * Fundamentally this is acceptable, as late-bindings should be treated as _eventually_ resolving anyways.
     *
     * @param binding - requested binding
     * @param requestCache - current request cache
     * @param supplierCache - current scope cache
     * @param lateBindingCache - map of any bindings that have been calculated already in the current request chain
     * @returns instantiated value, with all late-binding requests immediately resolving on the next event loop.
     * @throws if instantiation of providers fails, or when one of the late-binding chains fails after instantiation
     */
    #getSync(
        binding: GenericBinding,
        requestCache: ScopeCache,
        supplierCache: ScopeCache,
        lateBindingCache?: LateCache
    ): unknown {
        if (requestCache === supplierCache && !lateBindingCache) {
            for (const optimisticBinding of this.#requestMap.get(binding)!) {
                this.#getSync(optimisticBinding, requestCache, supplierCache);
            }
        }
        const lateBindCache = lateBindingCache ?? new Map<GenericBinding, { value: unknown }>();

        const { value, lateBindingRequests } = this.#getSyncImplementation(
            binding,
            requestCache,
            supplierCache,
            lateBindCache
        );

        try {
            for (const lateBindingRequest of lateBindingRequests) {
                const { supplier } = lateBindingRequest.dependencyId.annotations;
                const dependencyBinding = this.#baseIdToBinding.get(
                    lateBindingRequest.dependencyId.baseId()
                )!;
                if (typeof supplier === 'object') {
                    const relevantCache =
                        lateBindingRequest.binding.scope === supplierScope
                            ? supplierCache
                            : requestCache;
                    if (supplier.sync) {
                        lateBindingRequest.resolve(() => {
                            const scopeCache: ScopeCache = new Map();
                            return this.#getSync(
                                dependencyBinding,
                                supplier.propagateScope ? relevantCache : scopeCache,
                                scopeCache
                            );
                        });
                    } else {
                        lateBindingRequest.resolve(async () => {
                            const scopeCache: ScopeCache = new Map();
                            return this.#getMaybeSync(
                                dependencyBinding,
                                supplier.propagateScope ? relevantCache : scopeCache,
                                scopeCache
                            );
                        });
                    }
                } else {
                    const val = this.#getSync(
                        dependencyBinding,
                        requestCache,
                        supplierCache,
                        new Map([...lateBindCache, ...lateBindingRequest.registry])
                    );
                    lateBindingRequest.resolve(val);
                }
            }
        } catch (err) {
            for (const { reject } of lateBindingRequests) {
                reject(err);
            }
            throw err;
        }

        return value;
    }

    /**
     * Expose private field via a symbol to provide close to private functionality,
     * while still being accessible in the same file so it can be properly exposed in the {@link SyncContainer}.
     *
     * @returns normally private getSync method
     */
    protected get [getSyncSym](): (
        binding: GenericBinding,
        requestCache: ScopeCache,
        supplierCache: ScopeCache,
        lateBindingCache?: LateCache
    ) => unknown {
        return this.#getSync.bind(this);
    }
}

/**
 * Extension of AsyncContainer that also supports all methods in a synchronous manner.
 * Also supports async for general consistency, although all computation is fundamentally synchronous under the hood.
 *
 * @see {@link AsyncContainer} for more documentation
 */
export class SyncContainer<Outputs extends [Extendable]> extends AsyncContainer<Outputs> {
    /**
     * Create a synchronous container from module bindings.
     *
     * @param bindings - module bindings to create container from
     * @returns synchronous container (that also supports async)
     */
    public static [createContainerSym]?<Outputs extends [Extendable]>(
        bindings: ReadonlyMap<GenericOutputHaywireId, GenericBinding> | SyncContainer<Outputs>
    ): SyncContainer<Outputs> {
        return new SyncContainer<Outputs>(bindings);
    }

    /**
     * Sync version of {@link preload}.
     *
     * Instantiates all optimistic singletons.
     */
    public preload(): void {
        this[preloadSyncSym]();
    }

    /**
     * Sync version of {@link get}.
     *
     * Type checking enforces that the requested identifier exists in the container, and translates requested id to response type.
     *
     * Will preload all singletons if not already done.
     */
    public get<Id extends GenericHaywireId>(
        id: Id,
        ...invalidInput: [] &
            ([
                NonExtendable<
                    HaywireIdType<OutputHaywireId<Id>>,
                    Id['construct'],
                    Id['annotations']['named']
                >,
            ] extends Outputs
                ? []
                : [InvalidInput<'NoBindingExists'>])
    ): HaywireIdType<OutputHaywireId<Id>>;
    public get<Constructor extends IsClass>(
        clazz: Constructor,
        ...invalidInput: [] &
            ([NonExtendable<InstanceOfClass<Constructor>, Constructor, null>] extends Outputs
                ? []
                : [InvalidInput<'NoBindingExists'>])
    ): InstanceOfClass<Constructor>;
    public get<Id extends GenericHaywireId>(idOrClass: Id): HaywireIdType<OutputHaywireId<Id>> {
        const id = unsafeIdentifier(idOrClass).supplier(false).lateBinding(false);
        const binding = this.idToBinding.get(id);
        if (!binding) {
            throw new HaywireProviderMissingError([id]);
        }
        this[preloadSyncSym]();
        const requestCache: ScopeCache = new Map();
        return this[getSyncSym](binding, requestCache, requestCache) as HaywireIdType<
            OutputHaywireId<Id>
        >;
    }
}

export const isSyncContainer = <Outputs extends [Extendable]>(
    container: AsyncContainer<Outputs>
): container is SyncContainer<Outputs> => container instanceof SyncContainer;

export const createSyncContainer = SyncContainer[createContainerSym]!;
delete SyncContainer[createContainerSym];

export const createAsyncContainer = AsyncContainer[createContainerSym]!;
delete AsyncContainer[createContainerSym];

export const addBoundInstances = AsyncContainer[addBoundInstancesSym]!;
delete AsyncContainer[addBoundInstancesSym];
