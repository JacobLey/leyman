import type { Done, HookFunction, Context as MochaContext, Test as MochaTest } from 'mocha';
import pDefer from 'p-defer';
import { acquireLock, checkLock } from './execution-lock.js';
import {
    type AllowableAdditionalContext,
    type MergeContext,
    mergeContexts,
} from './merge-context.js';

/**
 * Before/After hooks run only once in the lifecycle of tests.
 *
 * Therefore the incoming context must be a single promise, and it will emit a single promise.
 *
 * The invocation of the hook cb will be wrapped by promise that will load the incoming context,
 * and pass it to the actual cb.
 *
 * The context returned by the hook will be resolved into the deferred promise that is returned on initial call.
 *
 * @param hook - hook function provided by mocha
 * @param existing - promise of contexts generated by previous hooks
 * @param args - arguments passed to hook, optionally with a title and callback
 * @returns promise of merged context between existing and extra context created in this hook
 */
export const wrapOneTimeHookWithContext = async <
    ExistingContext extends object,
    AdditionalContext extends AllowableAdditionalContext,
>(
    /**
     * Mocha's before/after hook
     */
    hook: HookFunction,
    /**
     * Incoming promise of context.
     */
    existing: Promise<ExistingContext>,
    /**
     * Agruments passed to hook.
     * Either is plain hook, or prepended with a title.
     */
    args:
        | [
              (
                  this: MochaContext,
                  ctx: ExistingContext,
                  done: Done
              ) => AdditionalContext | Promise<AdditionalContext>,
          ]
        | [
              string,
              (
                  this: MochaContext,
                  ctx: ExistingContext,
                  done: Done
              ) => AdditionalContext | Promise<AdditionalContext>,
          ]
): Promise<MergeContext<ExistingContext, Awaited<AdditionalContext>>> => {
    checkLock();

    const cb = args.length === 1 ? args[0] : args[1];

    const deferred = pDefer<AdditionalContext>();

    const doneCb = function (this: MochaContext, done: Done): void {
        acquireLock(this.runnable());
        void Promise.resolve().then(async () => {
            try {
                const additional = await cb.call(this, { ...(await existing) }, done);
                deferred.resolve(additional);
            } catch (err) {
                // eslint-disable-next-line n/callback-return
                done(err);
            }
        });
    };

    const asyncCb = async function (this: MochaContext): Promise<void> {
        acquireLock(this.runnable());
        const additional = await cb.apply(this, [{ ...(await existing) }] as unknown as [
            ExistingContext,
            Done,
        ]);
        deferred.resolve(additional);
    };

    const wrappedCb = cb.length > 1 ? doneCb : asyncCb;

    if (typeof args[0] === 'string') {
        hook(args[0], wrappedCb);
    } else {
        hook(wrappedCb);
    }

    return mergeContexts(existing, deferred.promise);
};

/**
 * BeforeEach/AfterEach hooks runs for each test context.
 *
 * Therefore the incoming context mapped by test context, and will similarly emit context in a map.
 *
 * The invocation of the hook cb will be wrapped by promise that will load the incoming context,
 * and pass it to the actual cb.
 *
 * The context returned by the hook will be resolved into the deferred promise that is returned on initial call.
 *
 * @param hook - hook provided by mocha
 * @param existingMap - Map getter of test instance to context
 * @param args - arguments passed to hook by caller, optionally with callback and title
 * @returns map of test instance to context
 */
export const wrapPerTestHookWithContext = <
    ExistingContext extends object,
    AdditionalContext extends AllowableAdditionalContext,
>(
    /**
     * Mocha's beforeEach/afterEach hook
     */
    hook: HookFunction,
    /**
     * Incoming promise of context, mapped by Test.
     *
     * While implemention is recommended to be a WeakMap, technically it can be anything that implements `get`.
     * This is useful for cases like entrypoint and one-time mapping, which will return the same value regardless
     * of what "key" is provided
     */
    existingMap: Pick<WeakMap<MochaTest, Promise<ExistingContext>>, 'get'>,
    /**
     * Agruments passed to hook.
     * Either is plain hook, or prepended with a title.
     */
    args:
        | [
              (
                  this: MochaContext,
                  ctx: ExistingContext,
                  done: Done
              ) => AdditionalContext | Promise<AdditionalContext>,
          ]
        | [
              string,
              (
                  this: MochaContext,
                  ctx: ExistingContext,
                  done: Done
              ) => AdditionalContext | Promise<AdditionalContext>,
          ]
): WeakMap<MochaTest, Promise<MergeContext<ExistingContext, Awaited<AdditionalContext>>>> => {
    checkLock();

    const cb = args.length === 1 ? args[0] : args[1];

    // Initial map is not populated.
    // A new map is initiated per call to beforeEach/afterEach.
    // Map will always be populated for downstream consumers because it is either:
    // 1) Written with a deferred promise before invoking cb
    // 2) Writes after cb is invoked, but before test is complete
    const testToPromise = new WeakMap<
        MochaTest,
        Promise<MergeContext<ExistingContext, Awaited<AdditionalContext>>>
    >();

    const doneCb = function (this: MochaContext, done: Done): void {
        acquireLock(this.runnable());
        void Promise.resolve().then(async () => {
            try {
                const existing = await existingMap.get(this.currentTest!)!;
                const deferred =
                    pDefer<MergeContext<ExistingContext, Awaited<AdditionalContext>>>();
                testToPromise.set(this.currentTest!, deferred.promise);
                const additional = await cb.call(this, { ...existing }, done);
                deferred.resolve(await mergeContexts(existing, additional));
            } catch (err) {
                // eslint-disable-next-line n/callback-return
                done(err);
            }
        });
    };

    const asyncCb = async function (this: MochaContext): Promise<void> {
        acquireLock(this.runnable());
        const existing = await existingMap.get(this.currentTest!)!;
        const additional = await cb.apply(this, [{ ...existing }] as unknown as [
            ExistingContext,
            Done,
        ]);
        testToPromise.set(this.currentTest!, mergeContexts(existing, additional));
    };

    const wrappedCb = cb.length > 1 ? doneCb : asyncCb;

    if (typeof args[0] === 'string') {
        hook(args[0], wrappedCb);
    } else {
        hook(wrappedCb);
    }

    return testToPromise;
};

export interface GenericContextualHook {
    (fn: (this: MochaContext, ctx: object, done: Done) => AllowableAdditionalContext): object;
    (
        name: string,
        fn: (this: MochaContext, ctx: object, done: Done) => AllowableAdditionalContext
    ): object;
}

/**
 * Hooks that are used as the "entrypoint" (not propagating any context)
 * should not provide the context as a parameter to the callback (for simplicity).
 *
 * Wrap the callback in another that strips out the context.
 *
 * @param contextualHook - hook generated by mocha-chain that usually passes a context to the caller
 * @returns hook function that no longer passes a context, but can still generate context for chained methods
 */
export const wrapHookWithEntrypoint =
    (
        /**
         * Hook that contains "propagated" empty context.
         */
        contextualHook: GenericContextualHook
    ): ((
        ...args:
            | [(this: MochaContext, done: Done) => AllowableAdditionalContext]
            | [string, (this: MochaContext, done: Done) => AllowableAdditionalContext]
    ) => object) =>
    (...args) => {
        const cb = args.length === 1 ? args[0] : args[1];
        if (typeof args[0] === 'string') {
            if (cb.length > 0) {
                return contextualHook(args[0], function (this, _, done) {
                    return cb.call(this, done);
                });
            }
            return contextualHook(args[0], function (this: MochaContext) {
                return cb.apply(this, [] as unknown as [Done]);
            });
        }

        if (cb.length > 0) {
            return contextualHook(function (this, _, done) {
                return cb.call(this, done);
            });
        }
        return contextualHook(function (this: MochaContext) {
            return cb.apply(this, [] as unknown as [Done]);
        });
    };
